const setExpressionsPlugin = (value) => {
  expressionsPlugin = value
}
const getExpressionsPlugin = () => expressionsPlugin
const setExpressionInterfaces = (value) => {
  expressionsInterfaces = value
}
const getExpressionInterfaces = () => expressionsInterfaces


function registerEffect$1(id, effect, countsAsEffect) {
  registeredEffects$1[id] = {
    countsAsEffect,
    effect,
  }
}

function ShapeTransformManager() {
  this.sequences = {}
  this.sequenceList = []
  this.transform_key_count = 0
}

ShapeTransformManager.prototype = {
  addTransformSequence: function (transforms) {
    let i
    var len = transforms.length
    var key = '_'
    for (i = 0; i < len; i += 1) {
      key += `${transforms[i].transform.key  }_`;
    }
    let sequence = this.sequences[key]
    if (!sequence) {
      sequence = {
        _mdf: false,
        finalTransform: new Matrix(),
        transforms: [].concat(transforms),
      }
      this.sequences[key] = sequence
      this.sequenceList.push(sequence)
    }
    return sequence
  },
  getNewKey: function () {
    this.transform_key_count += 1;
    return '_' + this.transform_key_count;
  },
  processSequence: function (sequence, isFirstFrame) {
    var i = 0;
    var len = sequence.transforms.length;
    var _mdf = isFirstFrame;
    while (i < len && !isFirstFrame) {
      if (sequence.transforms[i].transform.mProps._mdf) {
        _mdf = true;
        break;
      }
      i += 1;
    }
    if (_mdf) {
      sequence.finalTransform.reset();
      for (i = len - 1; i >= 0; i -= 1) {
        sequence.finalTransform.multiply(sequence.transforms[i].transform.mProps.v);
      }
    }
    sequence._mdf = _mdf;
  },
  processSequences: function (isFirstFrame) {
    var i;
    var len = this.sequenceList.length;
    for (i = 0; i < len; i += 1) {
      this.processSequence(this.sequenceList[i], isFirstFrame);
    }
  },
}

var lumaLoader = function () {
  let id = '__lottie_element_luma_buffer'
  var lumaBuffer = null
  var lumaBufferCtx = null
  var svg = null

  // This alternate solution has a slight delay before the filter is applied, resulting in a flicker on the first frame.
  // Keeping this here for reference, and in the future, if offscreen canvas supports url filters, this can be used.
  // For now, neither of them work for offscreen canvas, so canvas workers can't support the luma track matte mask.
  // Naming it solution 2 to mark the extra comment lines.
  /*
  var svgString = [
    '<svg xmlns="http://www.w3.org/2000/svg">',
    '<filter id="' + id + '">',
    '<feColorMatrix type="matrix" color-interpolation-filters="sRGB" values="',
    '0.3, 0.3, 0.3, 0, 0, ',
    '0.3, 0.3, 0.3, 0, 0, ',
    '0.3, 0.3, 0.3, 0, 0, ',
    '0.3, 0.3, 0.3, 0, 0',
    '"/>',
    '</filter>',
    '</svg>',
  ].join('');
  var blob = new Blob([svgString], { type: 'image/svg+xml' });
  var url = URL.createObjectURL(blob);
  */

  function createLumaSvgFilter() {
    let _svg = createNS('svg')
    var fil = createNS('filter')
    var matrix = createNS('feColorMatrix')
    fil.setAttribute('id', id)
    matrix.setAttribute('type', 'matrix')
    matrix.setAttribute('color-interpolation-filters', 'sRGB')
    matrix.setAttribute(
      'values',
      '0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0'
    )
    fil.appendChild(matrix)
    _svg.appendChild(fil)
    _svg.setAttribute('id', `${id  }_svg`)
    if (featureSupport.svgLumaHidden) {
      _svg.style.display = 'none'
    }
    return _svg
  }

  function loadLuma() {
    if (!lumaBuffer) {
      svg = createLumaSvgFilter()
      document.body.appendChild(svg)
      lumaBuffer = createTag('canvas')
      lumaBufferCtx = lumaBuffer.getContext('2d')
      // lumaBufferCtx.filter = `url('${url}#__lottie_element_luma_buffer')`; // part of solution 2
      lumaBufferCtx.filter = `url(#${  id  })`;
      lumaBufferCtx.fillStyle = 'rgba(0,0,0,0)'
      lumaBufferCtx.fillRect(0, 0, 1, 1)
    }
  }

  function getLuma(canvas) {
    if (!lumaBuffer) {
      loadLuma()
    }
    lumaBuffer.width = canvas.width
    lumaBuffer.height = canvas.height
    // lumaBufferCtx.filter = `url('${url}#__lottie_element_luma_buffer')`; // part of solution 2
    lumaBufferCtx.filter = `url(#${  id  })`;
    return lumaBuffer
  }
  return {
    get: getLuma,
    load: loadLuma,
  }
});

function createCanvas(width, height) {
  if (featureSupport.offscreenCanvas) {
    return new OffscreenCanvas(width, height)
  }
  let canvas = createTag('canvas')
  canvas.width = width
  canvas.height = height
  return canvas
}

const assetLoader = (function () {
  return {
    createCanvas: createCanvas,
    getLumaCanvas: lumaLoader.get,
    loadLumaCanvas: lumaLoader.load,
  }
}())

var registeredEffects = {}

function CVEffects(elem) {
  let i
  var len = elem.data.ef ? elem.data.ef.length : 0
  this.filters = []
  var filterManager
  for (i = 0; i < len; i += 1) {
    filterManager = null
    var type = elem.data.ef[i].ty
    if (registeredEffects[type]) {
      let Effect = registeredEffects[type].effect
      filterManager = new Effect(elem.effectsManager.effectElements[i], elem)
    }
    if (filterManager) {
      this.filters.push(filterManager)
    }
  }
  if (this.filters.length) {
    elem.addRenderableComponent(this)
  }
}

CVEffects.prototype.renderFrame = function (_isFirstFrame) {
  let i
  var len = this.filters.length
  for (i = 0; i < len; i += 1) {
    this.filters[i].renderFrame(_isFirstFrame)
  }
}

CVEffects.prototype.getEffects = function (type) {
  let i
  var len = this.filters.length
  var effects = []
  for (i = 0; i < len; i += 1) {
    if (this.filters[i].type === type) {
      effects.push(this.filters[i])
    }
  }
  return effects
};

function registerEffect(id, effect) {
  registeredEffects[id] = {
    effect,
  }
}

function CVMaskElement(data, element) {
  this.data = data
  this.element = element
  this.masksProperties = this.data.masksProperties || []
  this.viewData = createSizedArray(this.masksProperties.length)
  var i
  var len = this.masksProperties.length
  var hasMasks = false
  for (i = 0; i < len; i += 1) {
    if (this.masksProperties[i].mode !== 'n') {
      hasMasks = true
    }
    this.viewData[i] = ShapePropertyFactory.getShapeProp(
      this.element,
      this.masksProperties[i],
      3
    )
  }
  this.hasMasks = hasMasks
  if (hasMasks) {
    this.element.addRenderableComponent(this)
  }
}

CVMaskElement.prototype.renderFrame = function () {
  if (!this.hasMasks) {
    return
  }
  let transform = this.element.finalTransform.mat
  var ctx = this.element.canvasContext
  var i
  var len = this.masksProperties.length
  var pt
  var pts
  var data
  ctx.beginPath()
  for (i = 0; i < len; i += 1) {
    if (this.masksProperties[i].mode !== 'n') {
      if (this.masksProperties[i].inv) {
        ctx.moveTo(0, 0)
        ctx.lineTo(this.element.globalData.compSize.w, 0)
        ctx.lineTo(
          this.element.globalData.compSize.w,
          this.element.globalData.compSize.h
        )
        ctx.lineTo(0, this.element.globalData.compSize.h)
        ctx.lineTo(0, 0)
      }
      data = this.viewData[i].v
      pt = transform.applyToPointArray(data.v[0][0], data.v[0][1], 0)
      ctx.moveTo(pt[0], pt[1])
      var j
      var jLen = data._length
      for (j = 1; j < jLen; j += 1) {
        pts = transform.applyToTriplePoints(data.o[j - 1], data.i[j], data.v[j])
        ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5])
      }
      pts = transform.applyToTriplePoints(data.o[j - 1], data.i[0], data.v[0])
      ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5])
    }
  }
  this.element.globalData.renderer.save(true)
  ctx.clip()
};

CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty

CVMaskElement.prototype.destroy = function () {
  this.element = null
};

function CVBaseElement() {}

let operationsMap = {
  1: 'source-in',
  2: 'source-out',
  3: 'source-in',
  4: 'source-out',
}

CVBaseElement.prototype = {
  clearCanvas: function (canvasContext) {
    canvasContext.clearRect(
      this.transformCanvas.tx,
      this.transformCanvas.ty,
      this.transformCanvas.w * this.transformCanvas.sx,
      this.transformCanvas.h * this.transformCanvas.sy
    );
  },
  createContainerElements: function () {
    // If the layer is masked we will use two buffers to store each different states of the drawing
    // This solution is not ideal for several reason. But unfortunately, because of the recursive
    // nature of the render tree, it's the only simple way to make sure one inner mask doesn't override an outer mask.
    // TODO: try to reduce the size of these buffers to the size of the composition contaning the layer
    // It might be challenging because the layer most likely is transformed in some way
    if (this.data.tt >= 1) {
      this.buffers = [];
      var canvasContext = this.globalData.canvasContext;
      var bufferCanvas = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
      this.buffers.push(bufferCanvas);
      var bufferCanvas2 = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
      this.buffers.push(bufferCanvas2);
      if (this.data.tt >= 3 && !document._isProxy) {
        assetLoader.loadLumaCanvas();
      }
    }
    this.canvasContext = this.globalData.canvasContext;
    this.transformCanvas = this.globalData.transformCanvas;
    this.renderableEffectsManager = new CVEffects(this);
    this.searchEffectTransforms();
  },
  createContent: function () {},
  createElements: function () {},
  createRenderableComponents: function () {
    this.maskManager = new CVMaskElement(this.data, this);
    this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
  },
  destroy: function () {
    this.canvasContext = null;
    this.data = null;
    this.globalData = null;
    this.maskManager.destroy();
  },
  exitLayer: function () {
    if (this.data.tt >= 1) {
      var buffer = this.buffers[1];
      // On the second buffer we store the current state of the global drawing
      // that only contains the content of this layer
      // (if it is a composition, it also includes the nested layers)
      var bufferCtx = buffer.getContext('2d');
      this.clearCanvas(bufferCtx);
      bufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
      // We clear the canvas again
      this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
      this.clearCanvas(this.canvasContext);
      this.canvasContext.setTransform(this.currentTransform);
      // We draw the mask
      const mask = this.comp.getElementById('tp' in this.data ? this.data.tp : this.data.ind - 1);
      mask.renderFrame(true);
      // We draw the second buffer (that contains the content of this layer)
      this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);

      // If the mask is a Luma matte, we need to do two extra painting operations
      // the _isProxy check is to avoid drawing a fake canvas in workers that will throw an error
      if (this.data.tt >= 3 && !document._isProxy) {
        // We copy the painted mask to a buffer that has a color matrix filter applied to it
        // that applies the rgb values to the alpha channel
        var lumaBuffer = assetLoader.getLumaCanvas(this.canvasContext.canvas);
        var lumaBufferCtx = lumaBuffer.getContext('2d');
        lumaBufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
        this.clearCanvas(this.canvasContext);
        // we repaint the context with the mask applied to it
        this.canvasContext.drawImage(lumaBuffer, 0, 0);
      }
      this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt];
      this.canvasContext.drawImage(buffer, 0, 0);
      // We finally draw the first buffer (that contains the content of the global drawing)
      // We use destination-over to draw the global drawing below the current layer
      this.canvasContext.globalCompositeOperation = 'destination-over';
      this.canvasContext.drawImage(this.buffers[0], 0, 0);
      this.canvasContext.setTransform(this.currentTransform);
      // We reset the globalCompositeOperation to source-over, the standard type of operation
      this.canvasContext.globalCompositeOperation = 'source-over';
    }
  },
  hideElement: function () {
    if (!this.hidden && (!this.isInRange || this.isTransparent)) {
      this.hidden = true;
    }
  },
  initRendererElement: function () {},
  mHelper: new Matrix(),
  prepareLayer: function () {
    if (this.data.tt >= 1) {
      var buffer = this.buffers[0];
      var bufferCtx = buffer.getContext('2d');
      this.clearCanvas(bufferCtx);
      // on the first buffer we store the current state of the global drawing
      bufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
      // The next four lines are to clear the canvas
      // TODO: Check if there is a way to clear the canvas without resetting the transform
      this.currentTransform = this.canvasContext.getTransform();
      this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
      this.clearCanvas(this.canvasContext);
      this.canvasContext.setTransform(this.currentTransform);
    }
  },
  renderFrame: function (forceRender) {
    if (this.hidden || this.data.hd) {
      return;
    }
    if (this.data.td === 1 && !forceRender) {
      return;
    }
    this.renderTransform();
    this.renderRenderable();
    this.renderLocalTransform();
    this.setBlendMode();
    var forceRealStack = this.data.ty === 0;
    this.prepareLayer();
    this.globalData.renderer.save(forceRealStack);
    this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props);
    this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity);
    this.renderInnerContent();
    this.globalData.renderer.restore(forceRealStack);
    this.exitLayer();
    if (this.maskManager.hasMasks) {
      this.globalData.renderer.restore(true);
    }
    if (this._isFirstFrame) {
      this._isFirstFrame = false;
    }
  },
  setBlendMode: function () {
    var globalData = this.globalData;
    if (globalData.blendMode !== this.data.bm) {
      globalData.blendMode = this.data.bm;
      var blendModeValue = getBlendMode(this.data.bm);
      globalData.canvasContext.globalCompositeOperation = blendModeValue;
    }
  },
  showElement: function () {
    if (this.isInRange && !this.isTransparent) {
      this.hidden = false;
      this._isFirstFrame = true;
      this.maskManager._isFirstFrame = true;
    }
  },
}
CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement
CVBaseElement.prototype.show = CVBaseElement.prototype.showElement

function CVShapeData(element, data, styles, transformsManager) {
  this.styledShapes = []
  this.tr = [0, 0, 0, 0, 0, 0]
  var ty = 4
  if (data.ty === 'rc') {
    ty = 5
  } else if (data.ty === 'el') {
    ty = 6
  } else if (data.ty === 'sr') {
    ty = 7
  }
  this.sh = ShapePropertyFactory.getShapeProp(element, data, ty, element)
  var i
  var len = styles.length
  var styledShape
  for (i = 0; i < len; i += 1) {
    if (!styles[i].closed) {
      styledShape = {
        transforms: transformsManager.addTransformSequence(
          styles[i].transforms
        ),
        trNodes: [],
      }
      this.styledShapes.push(styledShape)
      styles[i].elements.push(styledShape)
    }
  }
}

CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated

function CVShapeElement(data, globalData, comp) {
  this.shapes = []
  this.shapesData = data.shapes
  this.stylesList = []
  this.itemsData = []
  this.prevViewData = []
  this.shapeModifiers = []
  this.processedElements = []
  this.transformsManager = new ShapeTransformManager()
  this.initElement(data, globalData, comp)
}

extendPrototype(
  [
    BaseElement,
    TransformElement,
    CVBaseElement,
    IShapeElement,
    HierarchyElement,
    FrameElement,
    RenderableElement,
  ],
  CVShapeElement
)

CVShapeElement.prototype.initElement =
  RenderableDOMElement.prototype.initElement

CVShapeElement.prototype.transformHelper = { _opMdf: false, opacity: 1 }

CVShapeElement.prototype.dashResetter = []

CVShapeElement.prototype.createContent = function () {
  this.searchShapes(
    this.shapesData,
    this.itemsData,
    this.prevViewData,
    true,
    []
  )
}

CVShapeElement.prototype.createStyleElement = function (data, transforms) {
  let styleElem = {
    closed: data.hd === true,
    data: data,
    elements: [],
    preTransforms: this.transformsManager.addTransformSequence(transforms),
    transforms: [],
    type: data.ty,
  }
  var elementData = {}
  if (data.ty === 'fl' || data.ty === 'st') {
    elementData.c = PropertyFactory.getProp(this, data.c, 1, 255, this)
    if (!elementData.c.k) {
      styleElem.co =
        'rgb(' +
        bmFloor(elementData.c.v[0]) +
        ',' +
        bmFloor(elementData.c.v[1]) +
        ',' +
        bmFloor(elementData.c.v[2]) +
        ')'
    }
  } else if (data.ty === 'gf' || data.ty === 'gs') {
    elementData.s = PropertyFactory.getProp(this, data.s, 1, null, this)
    elementData.e = PropertyFactory.getProp(this, data.e, 1, null, this)
    elementData.h = PropertyFactory.getProp(
      this,
      data.h || { k: 0 },
      0,
      0.01,
      this
    )
    elementData.a = PropertyFactory.getProp(
      this,
      data.a || { k: 0 },
      0,
      degToRads,
      this
    )
    elementData.g = new GradientProperty(this, data.g, this)
  }
  elementData.o = PropertyFactory.getProp(this, data.o, 0, 0.01, this)
  if (data.ty === 'st' || data.ty === 'gs') {
    styleElem.lc = lineCapEnum[data.lc || 2]
    styleElem.lj = lineJoinEnum[data.lj || 2]
    if (data.lj == 1) {
      // eslint-disable-line eqeqeq
      styleElem.ml = data.ml
    }
    elementData.w = PropertyFactory.getProp(this, data.w, 0, null, this)
    if (!elementData.w.k) {
      styleElem.wi = elementData.w.v
    }
    if (data.d) {
      let d = new DashProperty(this, data.d, 'canvas', this)
      elementData.d = d
      if (!elementData.d.k) {
        styleElem.da = elementData.d.dashArray
        styleElem.do = elementData.d.dashoffset[0]
      }
    }
  } else {
    styleElem.r = data.r === 2 ? 'evenodd' : 'nonzero'
  }
  this.stylesList.push(styleElem)
  elementData.style = styleElem
  return elementData
};

CVShapeElement.prototype.createGroupElement = function () {
  let elementData = {
    it: [],
    prevViewData: [],
  }
  return elementData
};

CVShapeElement.prototype.createTransformElement = function (data) {
  let elementData = {
    transform: {
      _opMdf: false,
      key: this.transformsManager.getNewKey(),
      mProps: TransformPropertyFactory.getTransformProperty(this, data, this),
      op: PropertyFactory.getProp(this, data.o, 0, 0.01, this),
      opacity: 1,
    },
  }
  return elementData
};

CVShapeElement.prototype.createShapeElement = function (data) {
  let elementData = new CVShapeData(
    this,
    data,
    this.stylesList,
    this.transformsManager
  )

  this.shapes.push(elementData)
  this.addShapeToModifiers(elementData)
  return elementData
};

CVShapeElement.prototype.reloadShapes = function () {
  this._isFirstFrame = true
  var i
  var len = this.itemsData.length
  for (i = 0; i < len; i += 1) {
    this.prevViewData[i] = this.itemsData[i]
  }
  this.searchShapes(
    this.shapesData,
    this.itemsData,
    this.prevViewData,
    true,
    []
  )
  len = this.dynamicProperties.length
  for (i = 0; i < len; i += 1) {
    this.dynamicProperties[i].getValue()
  }
  this.renderModifiers()
  this.transformsManager.processSequences(this._isFirstFrame)
};

CVShapeElement.prototype.addTransformToStyleList = function (transform) {
  let i
  var len = this.stylesList.length
  for (i = 0; i < len; i += 1) {
    if (!this.stylesList[i].closed) {
      this.stylesList[i].transforms.push(transform)
    }
  }
}

CVShapeElement.prototype.removeTransformFromStyleList = function () {
  let i
  var len = this.stylesList.length
  for (i = 0; i < len; i += 1) {
    if (!this.stylesList[i].closed) {
      this.stylesList[i].transforms.pop()
    }
  }
}

CVShapeElement.prototype.closeStyles = function (styles) {
  let i
  var len = styles.length
  for (i = 0; i < len; i += 1) {
    styles[i].closed = true
  }
}

CVShapeElement.prototype.searchShapes = function (
  arr,
  itemsData,
  prevViewData,
  shouldRender,
  transforms
) {
  let i
  var len = arr.length - 1
  var j
  var jLen
  var ownStyles = []
  var ownModifiers = []
  var processedPos
  var modifier
  var currentTransform
  var ownTransforms = [].concat(transforms)
  for (i = len; i >= 0; i -= 1) {
    processedPos = this.searchProcessedElement(arr[i])
    if (!processedPos) {
      arr[i]._shouldRender = shouldRender
    } else {
      itemsData[i] = prevViewData[processedPos - 1]
    }
    if (
      arr[i].ty === 'fl' ||
      arr[i].ty === 'st' ||
      arr[i].ty === 'gf' ||
      arr[i].ty === 'gs'
    ) {
      if (!processedPos) {
        itemsData[i] = this.createStyleElement(arr[i], ownTransforms)
      } else {
        itemsData[i].style.closed = false
      }

      ownStyles.push(itemsData[i].style)
    } else if (arr[i].ty === 'gr') {
      if (!processedPos) {
        itemsData[i] = this.createGroupElement(arr[i])
      } else {
        jLen = itemsData[i].it.length
        for (j = 0; j < jLen; j += 1) {
          itemsData[i].prevViewData[j] = itemsData[i].it[j]
        }
      }
      this.searchShapes(
        arr[i].it,
        itemsData[i].it,
        itemsData[i].prevViewData,
        shouldRender,
        ownTransforms
      )
    } else if (arr[i].ty === 'tr') {
      if (!processedPos) {
        currentTransform = this.createTransformElement(arr[i])
        itemsData[i] = currentTransform
      }
      ownTransforms.push(itemsData[i])
      this.addTransformToStyleList(itemsData[i])
    } else if (
      arr[i].ty === 'sh' ||
      arr[i].ty === 'rc' ||
      arr[i].ty === 'el' ||
      arr[i].ty === 'sr'
    ) {
      if (!processedPos) {
        itemsData[i] = this.createShapeElement(arr[i])
      }
    } else if (
      arr[i].ty === 'tm' ||
      arr[i].ty === 'rd' ||
      arr[i].ty === 'pb' ||
      arr[i].ty === 'zz' ||
      arr[i].ty === 'op'
    ) {
      if (!processedPos) {
        modifier = ShapeModifiers.getModifier(arr[i].ty)
        modifier.init(this, arr[i])
        itemsData[i] = modifier
        this.shapeModifiers.push(modifier)
      } else {
        modifier = itemsData[i]
        modifier.closed = false
      }
      ownModifiers.push(modifier)
    } else if (arr[i].ty === 'rp') {
      if (!processedPos) {
        modifier = ShapeModifiers.getModifier(arr[i].ty)
        itemsData[i] = modifier
        modifier.init(this, arr, i, itemsData)
        this.shapeModifiers.push(modifier)
        shouldRender = false
      } else {
        modifier = itemsData[i]
        modifier.closed = true
      }
      ownModifiers.push(modifier)
    }
    this.addProcessedElement(arr[i], i + 1)
  }
  this.removeTransformFromStyleList()
  this.closeStyles(ownStyles)
  len = ownModifiers.length
  for (i = 0; i < len; i += 1) {
    ownModifiers[i].closed = true
  }
}

CVShapeElement.prototype.renderInnerContent = function () {
  this.transformHelper.opacity = 1
  this.transformHelper._opMdf = false
  this.renderModifiers()
  this.transformsManager.processSequences(this._isFirstFrame)
  this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true)
};

CVShapeElement.prototype.renderShapeTransform = function (
  parentTransform,
  groupTransform
) {
  if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {
    groupTransform.opacity = parentTransform.opacity
    groupTransform.opacity *= groupTransform.op.v
    groupTransform._opMdf = true
  }
}

CVShapeElement.prototype.drawLayer = function () {
  let i
  var len = this.stylesList.length
  var j
  var jLen
  var k
  var kLen
  var elems
  var nodes
  var renderer = this.globalData.renderer
  var ctx = this.globalData.canvasContext
  var type
  var currentStyle
  for (i = 0; i < len; i += 1) {
    currentStyle = this.stylesList[i]
    type = currentStyle.type

    // Skipping style when
    // Stroke width equals 0
    // style should not be rendered (extra unused repeaters)
    // current opacity equals 0
    // global opacity equals 0
    if (
      !(
        ((type === 'st' || type === 'gs') && currentStyle.wi === 0) ||
        !currentStyle.data._shouldRender ||
        currentStyle.coOp === 0 ||
        this.globalData.currentGlobalAlpha === 0
      )
    ) {
      renderer.save()
      elems = currentStyle.elements
      if (type === 'st' || type === 'gs') {
        renderer.ctxStrokeStyle(
          type === 'st' ? currentStyle.co : currentStyle.grd
        )
        // ctx.strokeStyle = type === 'st' ? currentStyle.co : currentStyle.grd;
        renderer.ctxLineWidth(currentStyle.wi)
        // ctx.lineWidth = currentStyle.wi;
        renderer.ctxLineCap(currentStyle.lc)
        // ctx.lineCap = currentStyle.lc;
        renderer.ctxLineJoin(currentStyle.lj)
        // ctx.lineJoin = currentStyle.lj;
        renderer.ctxMiterLimit(currentStyle.ml || 0)
        // ctx.miterLimit = currentStyle.ml || 0;
      } else {
        renderer.ctxFillStyle(
          type === 'fl' ? currentStyle.co : currentStyle.grd
        )
        // ctx.fillStyle = type === 'fl' ? currentStyle.co : currentStyle.grd;
      }
      renderer.ctxOpacity(currentStyle.coOp)
      if (type !== 'st' && type !== 'gs') {
        ctx.beginPath()
      }
      renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props)
      jLen = elems.length
      for (j = 0; j < jLen; j += 1) {
        if (type === 'st' || type === 'gs') {
          ctx.beginPath()
          if (currentStyle.da) {
            ctx.setLineDash(currentStyle.da)
            ctx.lineDashOffset = currentStyle.do
          }
        }
        nodes = elems[j].trNodes
        kLen = nodes.length

        for (k = 0; k < kLen; k += 1) {
          if (nodes[k].t === 'm') {
            ctx.moveTo(nodes[k].p[0], nodes[k].p[1])
          } else if (nodes[k].t === 'c') {
            ctx.bezierCurveTo(
              nodes[k].pts[0],
              nodes[k].pts[1],
              nodes[k].pts[2],
              nodes[k].pts[3],
              nodes[k].pts[4],
              nodes[k].pts[5]
            )
          } else {
            ctx.closePath()
          }
        }
        if (type === 'st' || type === 'gs') {
          // ctx.stroke();
          renderer.ctxStroke()
          if (currentStyle.da) {
            ctx.setLineDash(this.dashResetter)
          }
        }
      }
      if (type !== 'st' && type !== 'gs') {
        // ctx.fill(currentStyle.r);
        this.globalData.renderer.ctxFill(currentStyle.r)
      }
      renderer.restore()
    }
  }
}

CVShapeElement.prototype.renderShape = function (
  parentTransform,
  items,
  data,
  isMain
) {
  let i
  var len = items.length - 1
  var groupTransform
  groupTransform = parentTransform
  for (i = len; i >= 0; i -= 1) {
    if (items[i].ty === 'tr') {
      groupTransform = data[i].transform
      this.renderShapeTransform(parentTransform, groupTransform)
    } else if (
      items[i].ty === 'sh' ||
      items[i].ty === 'el' ||
      items[i].ty === 'rc' ||
      items[i].ty === 'sr'
    ) {
      this.renderPath(items[i], data[i])
    } else if (items[i].ty === 'fl') {
      this.renderFill(items[i], data[i], groupTransform)
    } else if (items[i].ty === 'st') {
      this.renderStroke(items[i], data[i], groupTransform)
    } else if (items[i].ty === 'gf' || items[i].ty === 'gs') {
      this.renderGradientFill(items[i], data[i], groupTransform)
    } else if (items[i].ty === 'gr') {
      this.renderShape(groupTransform, items[i].it, data[i].it)
    } else if (items[i].ty === 'tm') {
      //
    }
  }
  if (isMain) {
    this.drawLayer()
  }
}

CVShapeElement.prototype.renderStyledShape = function (styledShape, shape) {
  if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {
    let shapeNodes = styledShape.trNodes
    var paths = shape.paths
    var i
    var len
    var j
    var jLen = paths._length
    shapeNodes.length = 0
    var groupTransformMat = styledShape.transforms.finalTransform
    for (j = 0; j < jLen; j += 1) {
      let pathNodes = paths.shapes[j]
      if (pathNodes && pathNodes.v) {
        len = pathNodes._length
        for (i = 1; i < len; i += 1) {
          if (i === 1) {
            shapeNodes.push({
              p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0),
              t: 'm',
            })
          }
          shapeNodes.push({
            pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i]),
            t: 'c',
          })
        }
        if (len === 1) {
          shapeNodes.push({
            p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0),
            t: 'm',
          })
        }
        if (pathNodes.c && len) {
          shapeNodes.push({
            pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0]),
            t: 'c',
          })
          shapeNodes.push({
            t: 'z',
          })
        }
      }
    }
    styledShape.trNodes = shapeNodes
  }
}

CVShapeElement.prototype.renderPath = function (pathData, itemData) {
  if (pathData.hd !== true && pathData._shouldRender) {
    let i
    var len = itemData.styledShapes.length
    for (i = 0; i < len; i += 1) {
      this.renderStyledShape(itemData.styledShapes[i], itemData.sh)
    }
  }
}

CVShapeElement.prototype.renderFill = function (
  styleData,
  itemData,
  groupTransform
) {
  let styleElem = itemData.style

  if (itemData.c._mdf || this._isFirstFrame) {
    styleElem.co =
      'rgb(' +
      bmFloor(itemData.c.v[0]) +
      ',' +
      bmFloor(itemData.c.v[1]) +
      ',' +
      bmFloor(itemData.c.v[2]) +
      ')'
  }
  if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
    styleElem.coOp = itemData.o.v * groupTransform.opacity
  }
}

CVShapeElement.prototype.renderGradientFill = function (
  styleData,
  itemData,
  groupTransform
) {
  let styleElem = itemData.style
  var grd
  if (
    !styleElem.grd ||
    itemData.g._mdf ||
    itemData.s._mdf ||
    itemData.e._mdf ||
    (styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf))
  ) {
    let ctx = this.globalData.canvasContext
    var pt1 = itemData.s.v
    var pt2 = itemData.e.v
    if (styleData.t === 1) {
      grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1])
    } else {
      let rad = Math.sqrt(
        Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2)
      )
      let ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0])

      var percent = itemData.h.v
      if (percent >= 1) {
        percent = 0.99
      } else if (percent <= -1) {
        percent = -0.99
      }
      let dist = rad * percent
      var x = Math.cos(ang + itemData.a.v) * dist + pt1[0]
      var y = Math.sin(ang + itemData.a.v) * dist + pt1[1]
      grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad)
    }

    let i
    var len = styleData.g.p
    var cValues = itemData.g.c
    var opacity = 1

    for (i = 0; i < len; i += 1) {
      if (itemData.g._hasOpacity && itemData.g._collapsable) {
        opacity = itemData.g.o[i * 2 + 1]
      }
      grd.addColorStop(
        cValues[i * 4] / 100,
        'rgba(' +
          cValues[i * 4 + 1] +
          ',' +
          cValues[i * 4 + 2] +
          ',' +
          cValues[i * 4 + 3] +
          ',' +
          opacity +
          ')'
      )
    }
    styleElem.grd = grd
  }
  styleElem.coOp = itemData.o.v * groupTransform.opacity
};

CVShapeElement.prototype.renderStroke = function (
  styleData,
  itemData,
  groupTransform
) {
  let styleElem = itemData.style
  var d = itemData.d
  if (d && (d._mdf || this._isFirstFrame)) {
    styleElem.da = d.dashArray
    styleElem.do = d.dashoffset[0]
  }
  if (itemData.c._mdf || this._isFirstFrame) {
    styleElem.co =
      'rgb(' +
      bmFloor(itemData.c.v[0]) +
      ',' +
      bmFloor(itemData.c.v[1]) +
      ',' +
      bmFloor(itemData.c.v[2]) +
      ')'
  }
  if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
    styleElem.coOp = itemData.o.v * groupTransform.opacity
  }
  if (itemData.w._mdf || this._isFirstFrame) {
    styleElem.wi = itemData.w.v
  }
}

CVShapeElement.prototype.destroy = function () {
  this.shapesData = null
  this.globalData = null
  this.canvasContext = null
  this.stylesList.length = 0
  this.itemsData.length = 0
};

function CVTextElement(data, globalData, comp) {
  this.textSpans = []
  this.yOffset = 0
  this.fillColorAnim = false
  this.strokeColorAnim = false
  this.strokeWidthAnim = false
  this.stroke = false
  this.fill = false
  this.justifyOffset = 0
  this.currentRender = null
  this.renderType = 'canvas'
  this.values = {
    fill: 'rgba(0,0,0,0)',
    fValue: '',
    stroke: 'rgba(0,0,0,0)',
    sWidth: 0,
  }
  this.initElement(data, globalData, comp)
}
extendPrototype(
  [
    BaseElement,
    TransformElement,
    CVBaseElement,
    HierarchyElement,
    FrameElement,
    RenderableElement,
    ITextElement,
  ],
  CVTextElement
)

CVTextElement.prototype.tHelper = createTag('canvas').getContext('2d')

CVTextElement.prototype.buildNewText = function () {
  let documentData = this.textProperty.currentData
  this.renderedLetters = createSizedArray(
    documentData.l ? documentData.l.length : 0
  )

  let hasFill = false
  if (documentData.fc) {
    hasFill = true
    this.values.fill = this.buildColor(documentData.fc)
  } else {
    this.values.fill = 'rgba(0,0,0,0)'
  }
  this.fill = hasFill
  var hasStroke = false
  if (documentData.sc) {
    hasStroke = true
    this.values.stroke = this.buildColor(documentData.sc)
    this.values.sWidth = documentData.sw
  }
  let fontData = this.globalData.fontManager.getFontByName(documentData.f)
  var i
  var len
  var letters = documentData.l
  var matrixHelper = this.mHelper
  this.stroke = hasStroke
  this.values.fValue =
    documentData.finalSize +
    'px ' +
    this.globalData.fontManager.getFontByName(documentData.f).fFamily
  len = documentData.finalText.length
  // this.tHelper.font = this.values.fValue;
  var charData
  var shapeData
  var k
  var kLen
  var shapes
  var j
  var jLen
  var pathNodes
  var commands
  var pathArr
  var singleShape = this.data.singleShape
  var trackingOffset = documentData.tr * 0.001 * documentData.finalSize
  var xPos = 0
  var yPos = 0
  var firstLine = true
  var cnt = 0
  for (i = 0; i < len; i += 1) {
    charData = this.globalData.fontManager.getCharData(
      documentData.finalText[i],
      fontData.fStyle,
      this.globalData.fontManager.getFontByName(documentData.f).fFamily
    )
    shapeData = (charData && charData.data) || {}
    matrixHelper.reset()
    if (singleShape && letters[i].n) {
      xPos = -trackingOffset
      yPos += documentData.yOffset
      yPos += firstLine ? 1 : 0
      firstLine = false
    }
    shapes = shapeData.shapes ? shapeData.shapes[0].it : []
    jLen = shapes.length
    matrixHelper.scale(
      documentData.finalSize / 100,
      documentData.finalSize / 100
    )
    if (singleShape) {
      this.applyTextPropertiesToMatrix(
        documentData,
        matrixHelper,
        letters[i].line,
        xPos,
        yPos
      )
    }
    commands = createSizedArray(jLen - 1)
    var commandsCounter = 0
    for (j = 0; j < jLen; j += 1) {
      if (shapes[j].ty === 'sh') {
        kLen = shapes[j].ks.k.i.length
        pathNodes = shapes[j].ks.k
        pathArr = []
        for (k = 1; k < kLen; k += 1) {
          if (k === 1) {
            pathArr.push(
              matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0),
              matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0)
            )
          }
          pathArr.push(
            matrixHelper.applyToX(
              pathNodes.o[k - 1][0],
              pathNodes.o[k - 1][1],
              0
            ),
            matrixHelper.applyToY(
              pathNodes.o[k - 1][0],
              pathNodes.o[k - 1][1],
              0
            ),
            matrixHelper.applyToX(pathNodes.i[k][0], pathNodes.i[k][1], 0),
            matrixHelper.applyToY(pathNodes.i[k][0], pathNodes.i[k][1], 0),
            matrixHelper.applyToX(pathNodes.v[k][0], pathNodes.v[k][1], 0),
            matrixHelper.applyToY(pathNodes.v[k][0], pathNodes.v[k][1], 0)
          )
        }
        pathArr.push(
          matrixHelper.applyToX(
            pathNodes.o[k - 1][0],
            pathNodes.o[k - 1][1],
            0
          ),
          matrixHelper.applyToY(
            pathNodes.o[k - 1][0],
            pathNodes.o[k - 1][1],
            0
          ),
          matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0),
          matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0),
          matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0),
          matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0)
        )
        commands[commandsCounter] = pathArr
        commandsCounter += 1
      }
    }
    if (singleShape) {
      xPos += letters[i].l
      xPos += trackingOffset
    }
    if (this.textSpans[cnt]) {
      this.textSpans[cnt].elem = commands
    } else {
      this.textSpans[cnt] = { elem: commands }
    }
    cnt += 1
  }
}

CVTextElement.prototype.renderInnerContent = function () {
  this.validateText()
  var ctx = this.canvasContext
  ctx.font = this.values.fValue
  this.globalData.renderer.ctxLineCap('butt')
  // ctx.lineCap = 'butt';
  this.globalData.renderer.ctxLineJoin('miter')
  // ctx.lineJoin = 'miter';
  this.globalData.renderer.ctxMiterLimit(4)
  // ctx.miterLimit = 4;

  if (!this.data.singleShape) {
    this.textAnimator.getMeasures(
      this.textProperty.currentData,
      this.lettersChangedFlag
    )
  }

  let i
  var len
  var j
  var jLen
  var k
  var kLen
  var renderedLetters = this.textAnimator.renderedLetters

  var letters = this.textProperty.currentData.l

  len = letters.length
  var renderedLetter
  var lastFill = null
  var lastStroke = null
  var lastStrokeW = null
  var commands
  var pathArr
  var renderer = this.globalData.renderer
  for (i = 0; i < len; i += 1) {
    if (!letters[i].n) {
      renderedLetter = renderedLetters[i]
      if (renderedLetter) {
        renderer.save()
        renderer.ctxTransform(renderedLetter.p)
        renderer.ctxOpacity(renderedLetter.o)
      }
      if (this.fill) {
        if (renderedLetter && renderedLetter.fc) {
          if (lastFill !== renderedLetter.fc) {
            renderer.ctxFillStyle(renderedLetter.fc)
            lastFill = renderedLetter.fc
            // ctx.fillStyle = renderedLetter.fc;
          }
        } else if (lastFill !== this.values.fill) {
          lastFill = this.values.fill
          renderer.ctxFillStyle(this.values.fill)
          // ctx.fillStyle = this.values.fill;
        }
        commands = this.textSpans[i].elem
        jLen = commands.length
        this.globalData.canvasContext.beginPath()
        for (j = 0; j < jLen; j += 1) {
          pathArr = commands[j]
          kLen = pathArr.length
          this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1])
          for (k = 2; k < kLen; k += 6) {
            this.globalData.canvasContext.bezierCurveTo(
              pathArr[k],
              pathArr[k + 1],
              pathArr[k + 2],
              pathArr[k + 3],
              pathArr[k + 4],
              pathArr[k + 5]
            )
          }
        }
        this.globalData.canvasContext.closePath()
        renderer.ctxFill()
        // this.globalData.canvasContext.fill();
        /// ctx.fillText(this.textSpans[i].val,0,0);
      }
      if (this.stroke) {
        if (renderedLetter && renderedLetter.sw) {
          if (lastStrokeW !== renderedLetter.sw) {
            lastStrokeW = renderedLetter.sw
            renderer.ctxLineWidth(renderedLetter.sw)
            // ctx.lineWidth = renderedLetter.sw;
          }
        } else if (lastStrokeW !== this.values.sWidth) {
          lastStrokeW = this.values.sWidth
          renderer.ctxLineWidth(this.values.sWidth)
          // ctx.lineWidth = this.values.sWidth;
        }
        if (renderedLetter && renderedLetter.sc) {
          if (lastStroke !== renderedLetter.sc) {
            lastStroke = renderedLetter.sc
            renderer.ctxStrokeStyle(renderedLetter.sc)
            // ctx.strokeStyle = renderedLetter.sc;
          }
        } else if (lastStroke !== this.values.stroke) {
          lastStroke = this.values.stroke
          renderer.ctxStrokeStyle(this.values.stroke)
          // ctx.strokeStyle = this.values.stroke;
        }
        commands = this.textSpans[i].elem
        jLen = commands.length
        this.globalData.canvasContext.beginPath()
        for (j = 0; j < jLen; j += 1) {
          pathArr = commands[j]
          kLen = pathArr.length
          this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1])
          for (k = 2; k < kLen; k += 6) {
            this.globalData.canvasContext.bezierCurveTo(
              pathArr[k],
              pathArr[k + 1],
              pathArr[k + 2],
              pathArr[k + 3],
              pathArr[k + 4],
              pathArr[k + 5]
            )
          }
        }
        this.globalData.canvasContext.closePath()
        renderer.ctxStroke()
        // this.globalData.canvasContext.stroke();
        /// ctx.strokeText(letters[i].val,0,0);
      }
      if (renderedLetter) {
        this.globalData.renderer.restore()
      }
    }
  }
}

function CVImageElement(data, globalData, comp) {
  this.assetData = globalData.getAssetData(data.refId)
  this.img = globalData.imageLoader.getAsset(this.assetData)
  this.initElement(data, globalData, comp)
}
extendPrototype(
  [
    BaseElement,
    TransformElement,
    CVBaseElement,
    HierarchyElement,
    FrameElement,
    RenderableElement,
  ],
  CVImageElement
)

CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement
CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame

CVImageElement.prototype.createContent = function () {
  if (
    this.img.width &&
    (this.assetData.w !== this.img.width ||
      this.assetData.h !== this.img.height)
  ) {
    let canvas = createTag('canvas')
    canvas.width = this.assetData.w
    canvas.height = this.assetData.h
    var ctx = canvas.getContext('2d')

    var imgW = this.img.width
    var imgH = this.img.height
    var imgRel = imgW / imgH
    var canvasRel = this.assetData.w / this.assetData.h
    var widthCrop
    var heightCrop
    var par =
      this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio
    if (
      (imgRel > canvasRel && par === 'xMidYMid slice') ||
      (imgRel < canvasRel && par !== 'xMidYMid slice')
    ) {
      heightCrop = imgH
      widthCrop = heightCrop * canvasRel
    } else {
      widthCrop = imgW
      heightCrop = widthCrop / canvasRel
    }
    ctx.drawImage(
      this.img,
      (imgW - widthCrop) / 2,
      (imgH - heightCrop) / 2,
      widthCrop,
      heightCrop,
      0,
      0,
      this.assetData.w,
      this.assetData.h
    )
    this.img = canvas
  }
}

CVImageElement.prototype.renderInnerContent = function () {
  this.canvasContext.drawImage(this.img, 0, 0)
};

CVImageElement.prototype.destroy = function () {
  this.img = null
};

function CVSolidElement(data, globalData, comp) {
  this.initElement(data, globalData, comp)
}
extendPrototype(
  [
    BaseElement,
    TransformElement,
    CVBaseElement,
    HierarchyElement,
    FrameElement,
    RenderableElement,
  ],
  CVSolidElement
)

CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement
CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame

CVSolidElement.prototype.renderInnerContent = function () {
  // var ctx = this.canvasContext;
  this.globalData.renderer.ctxFillStyle(this.data.sc)
  // ctx.fillStyle = this.data.sc;
  this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh)
  // ctx.fillRect(0, 0, this.data.sw, this.data.sh);
  //
};

function CanvasRendererBase() {}
extendPrototype([BaseRenderer], CanvasRendererBase)

CanvasRendererBase.prototype.createShape = function (data) {
  return new CVShapeElement(data, this.globalData, this)
};

CanvasRendererBase.prototype.createText = function (data) {
  return new CVTextElement(data, this.globalData, this)
};

CanvasRendererBase.prototype.createImage = function (data) {
  return new CVImageElement(data, this.globalData, this)
};

CanvasRendererBase.prototype.createSolid = function (data) {
  return new CVSolidElement(data, this.globalData, this)
};

CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull

CanvasRendererBase.prototype.ctxTransform = function (props) {
  if (
    props[0] === 1 &&
    props[1] === 0 &&
    props[4] === 0 &&
    props[5] === 1 &&
    props[12] === 0 &&
    props[13] === 0
  ) {
    return
  }
  this.canvasContext.transform(
    props[0],
    props[1],
    props[4],
    props[5],
    props[12],
    props[13]
  )
}

CanvasRendererBase.prototype.ctxOpacity = function (op) {
  this.canvasContext.globalAlpha *= op < 0 ? 0 : op
};

CanvasRendererBase.prototype.ctxFillStyle = function (value) {
  this.canvasContext.fillStyle = value
};

CanvasRendererBase.prototype.ctxStrokeStyle = function (value) {
  this.canvasContext.strokeStyle = value
};

CanvasRendererBase.prototype.ctxLineWidth = function (value) {
  this.canvasContext.lineWidth = value
};

CanvasRendererBase.prototype.ctxLineCap = function (value) {
  this.canvasContext.lineCap = value
};

CanvasRendererBase.prototype.ctxLineJoin = function (value) {
  this.canvasContext.lineJoin = value
};

CanvasRendererBase.prototype.ctxMiterLimit = function (value) {
  this.canvasContext.miterLimit = value
};

CanvasRendererBase.prototype.ctxFill = function (rule) {
  this.canvasContext.fill(rule)
};

CanvasRendererBase.prototype.ctxFillRect = function (x, y, w, h) {
  this.canvasContext.fillRect(x, y, w, h)
};

CanvasRendererBase.prototype.ctxStroke = function () {
  this.canvasContext.stroke()
};

CanvasRendererBase.prototype.reset = function () {
  if (!this.renderConfig.clearCanvas) {
    this.canvasContext.restore()
    return;
  }
  this.contextData.reset()
};

CanvasRendererBase.prototype.save = function () {
  this.canvasContext.save()
};

CanvasRendererBase.prototype.restore = function (actionFlag) {
  if (!this.renderConfig.clearCanvas) {
    this.canvasContext.restore()
    return;
  }
  if (actionFlag) {
    this.globalData.blendMode = 'source-over'
  }
  this.contextData.restore(actionFlag)
};

CanvasRendererBase.prototype.configAnimation = function (animData) {
  if (this.animationItem.wrapper) {
    this.animationItem.container = createTag('canvas')
    var containerStyle = this.animationItem.container.style
    containerStyle.width = '100%'
    containerStyle.height = '100%'
    var origin = '0px 0px 0px'
    containerStyle.transformOrigin = origin
    containerStyle.mozTransformOrigin = origin
    containerStyle.webkitTransformOrigin = origin
    containerStyle['-webkit-transform'] = origin
    containerStyle.contentVisibility = this.renderConfig.contentVisibility
    this.animationItem.wrapper.appendChild(this.animationItem.container)
    this.canvasContext = this.animationItem.container.getContext('2d')
    if (this.renderConfig.className) {
      this.animationItem.container.setAttribute(
        'class',
        this.renderConfig.className
      )
    }
    if (this.renderConfig.id) {
      this.animationItem.container.setAttribute('id', this.renderConfig.id)
    }
  } else {
    this.canvasContext = this.renderConfig.context
  }
  this.contextData.setContext(this.canvasContext)
  this.data = animData
  this.layers = animData.layers
  this.transformCanvas = {
    h: animData.h,
    sx: 0,
    sy: 0,
    tx: 0,
    ty: 0,
    w: animData.w,
  }
  this.setupGlobalData(animData, document.body)
  this.globalData.canvasContext = this.canvasContext
  this.globalData.renderer = this
  this.globalData.isDashed = false
  this.globalData.progressiveLoad = this.renderConfig.progressiveLoad
  this.globalData.transformCanvas = this.transformCanvas
  this.elements = createSizedArray(animData.layers.length)

  this.updateContainerSize()
};

CanvasRendererBase.prototype.updateContainerSize = function (width, height) {
  this.reset()
  var elementWidth
  var elementHeight
  if (width) {
    elementWidth = width
    elementHeight = height
    this.canvasContext.canvas.width = elementWidth
    this.canvasContext.canvas.height = elementHeight
  } else {
    if (this.animationItem.wrapper && this.animationItem.container) {
      elementWidth = this.animationItem.wrapper.offsetWidth
      elementHeight = this.animationItem.wrapper.offsetHeight
    } else {
      elementWidth = this.canvasContext.canvas.width
      elementHeight = this.canvasContext.canvas.height
    }
    this.canvasContext.canvas.width = elementWidth * this.renderConfig.dpr
    this.canvasContext.canvas.height = elementHeight * this.renderConfig.dpr
  }

  let elementRel
  var animationRel
  if (
    this.renderConfig.preserveAspectRatio.indexOf('meet') !== -1 ||
    this.renderConfig.preserveAspectRatio.indexOf('slice') !== -1
  ) {
    let par = this.renderConfig.preserveAspectRatio.split(' ')
    var fillType = par[1] || 'meet'
    var pos = par[0] || 'xMidYMid'
    var xPos = pos.substr(0, 4)
    var yPos = pos.substr(4)
    elementRel = elementWidth / elementHeight
    animationRel = this.transformCanvas.w / this.transformCanvas.h
    if (
      (animationRel > elementRel && fillType === 'meet') ||
      (animationRel < elementRel && fillType === 'slice')
    ) {
      this.transformCanvas.sx =
        elementWidth / (this.transformCanvas.w / this.renderConfig.dpr)
      this.transformCanvas.sy =
        elementWidth / (this.transformCanvas.w / this.renderConfig.dpr)
    } else {
      this.transformCanvas.sx =
        elementHeight / (this.transformCanvas.h / this.renderConfig.dpr)
      this.transformCanvas.sy =
        elementHeight / (this.transformCanvas.h / this.renderConfig.dpr)
    }

    if (
      xPos === 'xMid' &&
      ((animationRel < elementRel && fillType === 'meet') ||
        (animationRel > elementRel && fillType === 'slice'))
    ) {
      this.transformCanvas.tx =
        ((elementWidth -
          this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) /
          2) *
        this.renderConfig.dpr
    } else if (
      xPos === 'xMax' &&
      ((animationRel < elementRel && fillType === 'meet') ||
        (animationRel > elementRel && fillType === 'slice'))
    ) {
      this.transformCanvas.tx =
        (elementWidth -
          this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) *
        this.renderConfig.dpr
    } else {
      this.transformCanvas.tx = 0
    }
    if (
      yPos === 'YMid' &&
      ((animationRel > elementRel && fillType === 'meet') ||
        (animationRel < elementRel && fillType === 'slice'))
    ) {
      this.transformCanvas.ty =
        ((elementHeight -
          this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) /
          2) *
        this.renderConfig.dpr
    } else if (
      yPos === 'YMax' &&
      ((animationRel > elementRel && fillType === 'meet') ||
        (animationRel < elementRel && fillType === 'slice'))
    ) {
      this.transformCanvas.ty =
        (elementHeight -
          this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) *
        this.renderConfig.dpr
    } else {
      this.transformCanvas.ty = 0
    }
  } else if (this.renderConfig.preserveAspectRatio === 'none') {
    this.transformCanvas.sx =
      elementWidth / (this.transformCanvas.w / this.renderConfig.dpr)
    this.transformCanvas.sy =
      elementHeight / (this.transformCanvas.h / this.renderConfig.dpr)
    this.transformCanvas.tx = 0
    this.transformCanvas.ty = 0
  } else {
    this.transformCanvas.sx = this.renderConfig.dpr
    this.transformCanvas.sy = this.renderConfig.dpr
    this.transformCanvas.tx = 0
    this.transformCanvas.ty = 0
  }
  this.transformCanvas.props = [
    this.transformCanvas.sx,
    0,
    0,
    0,
    0,
    this.transformCanvas.sy,
    0,
    0,
    0,
    0,
    1,
    0,
    this.transformCanvas.tx,
    this.transformCanvas.ty,
    0,
    1,
  ]
  /* var i, len = this.elements.length;
    for(i=0;i<len;i+=1){
        if(this.elements[i] && this.elements[i].data.ty === 0){
            this.elements[i].resize(this.globalData.transformCanvas);
        }
    } */
  this.ctxTransform(this.transformCanvas.props)
  this.canvasContext.beginPath()
  this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h)
  this.canvasContext.closePath()
  this.canvasContext.clip()

  this.renderFrame(this.renderedFrame, true)
};

CanvasRendererBase.prototype.destroy = function () {
  if (this.renderConfig.clearCanvas && this.animationItem.wrapper) {
    this.animationItem.wrapper.innerText = ''
  }
  let i
  var len = this.layers ? this.layers.length : 0
  for (i = len - 1; i >= 0; i -= 1) {
    if (this.elements[i] && this.elements[i].destroy) {
      this.elements[i].destroy()
    }
  }
  this.elements.length = 0
  this.globalData.canvasContext = null
  this.animationItem.container = null
  this.destroyed = true
};

CanvasRendererBase.prototype.renderFrame = function (num, forceRender) {
  if (
    (this.renderedFrame === num &&
      this.renderConfig.clearCanvas === true &&
      !forceRender) ||
    this.destroyed ||
    num === -1
  ) {
    return
  }
  this.renderedFrame = num
  this.globalData.frameNum = num - this.animationItem._isFirstFrame
  this.globalData.frameId += 1
  this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender
  this.globalData.projectInterface.currentFrame = num

  // console.log('--------');
  // console.log('NEW: ',num);
  var i
  var len = this.layers.length
  if (!this.completeLayers) {
    this.checkLayers(num)
  }

  for (i = len - 1; i >= 0; i -= 1) {
    if (this.completeLayers || this.elements[i]) {
      this.elements[i].prepareFrame(num - this.layers[i].st)
    }
  }
  if (this.globalData._mdf) {
    if (this.renderConfig.clearCanvas === true) {
      this.canvasContext.clearRect(
        0,
        0,
        this.transformCanvas.w,
        this.transformCanvas.h
      )
    } else {
      this.save()
    }
    for (i = len - 1; i >= 0; i -= 1) {
      if (this.completeLayers || this.elements[i]) {
        this.elements[i].renderFrame()
      }
    }
    if (this.renderConfig.clearCanvas !== true) {
      this.restore()
    }
  }
}

CanvasRendererBase.prototype.buildItem = function (pos) {
  let elements = this.elements
  if (elements[pos] || this.layers[pos].ty === 99) {
    return
  }
  let element = this.createItem(this.layers[pos], this, this.globalData)
  elements[pos] = element
  element.initExpressions()
  /* if(this.layers[pos].ty === 0){
        element.resize(this.globalData.transformCanvas);
    } */
};

CanvasRendererBase.prototype.checkPendingElements = function () {
  while (this.pendingElements.length) {
    let element = this.pendingElements.pop()
    element.checkParenting()
  }
}

CanvasRendererBase.prototype.hide = function () {
  this.animationItem.container.style.display = 'none'
};

CanvasRendererBase.prototype.show = function () {
  this.animationItem.container.style.display = 'block'
};

function CanvasContext() {
  this.opacity = -1
  this.transform = createTypedArray('float32', 16)
  this.fillStyle = ''
  this.strokeStyle = ''
  this.lineWidth = ''
  this.lineCap = ''
  this.lineJoin = ''
  this.miterLimit = ''
  this.id = Math.random()
}

function CVContextData() {
  this.stack = []
  this.cArrPos = 0
  this.cTr = new Matrix()
  var i
  var len = 15
  for (i = 0; i < len; i += 1) {
    let canvasContext = new CanvasContext()
    this.stack[i] = canvasContext
  }
  this._length = len
  this.nativeContext = null
  this.transformMat = new Matrix()
  this.currentOpacity = 1
  //
  this.currentFillStyle = ''
  this.appliedFillStyle = ''
  //
  this.currentStrokeStyle = ''
  this.appliedStrokeStyle = ''
  //
  this.currentLineWidth = ''
  this.appliedLineWidth = ''
  //
  this.currentLineCap = ''
  this.appliedLineCap = ''
  //
  this.currentLineJoin = ''
  this.appliedLineJoin = ''
  //
  this.appliedMiterLimit = ''
  this.currentMiterLimit = ''
}

CVContextData.prototype.duplicate = function () {
  let newLength = this._length * 2
  var i = 0
  for (i = this._length; i < newLength; i += 1) {
    this.stack[i] = new CanvasContext()
  }
  this._length = newLength
};

CVContextData.prototype.reset = function () {
  this.cArrPos = 0
  this.cTr.reset()
  this.stack[this.cArrPos].opacity = 1
};

CVContextData.prototype.restore = function (forceRestore) {
  this.cArrPos -= 1
  var currentContext = this.stack[this.cArrPos]
  var transform = currentContext.transform
  var i
  var arr = this.cTr.props
  for (i = 0; i < 16; i += 1) {
    arr[i] = transform[i]
  }
  if (forceRestore) {
    this.nativeContext.restore()
    var prevStack = this.stack[this.cArrPos + 1]
    this.appliedFillStyle = prevStack.fillStyle
    this.appliedStrokeStyle = prevStack.strokeStyle
    this.appliedLineWidth = prevStack.lineWidth
    this.appliedLineCap = prevStack.lineCap
    this.appliedLineJoin = prevStack.lineJoin
    this.appliedMiterLimit = prevStack.miterLimit
  }
  this.nativeContext.setTransform(
    transform[0],
    transform[1],
    transform[4],
    transform[5],
    transform[12],
    transform[13]
  )
  if (
    forceRestore ||
    (currentContext.opacity !== -1 &&
      this.currentOpacity !== currentContext.opacity)
  ) {
    this.nativeContext.globalAlpha = currentContext.opacity
    this.currentOpacity = currentContext.opacity
  }
  this.currentFillStyle = currentContext.fillStyle
  this.currentStrokeStyle = currentContext.strokeStyle
  this.currentLineWidth = currentContext.lineWidth
  this.currentLineCap = currentContext.lineCap
  this.currentLineJoin = currentContext.lineJoin
  this.currentMiterLimit = currentContext.miterLimit
};

CVContextData.prototype.save = function (saveOnNativeFlag) {
  if (saveOnNativeFlag) {
    this.nativeContext.save()
  }
  let props = this.cTr.props
  if (this._length <= this.cArrPos) {
    this.duplicate()
  }

  let currentStack = this.stack[this.cArrPos]
  var i
  for (i = 0; i < 16; i += 1) {
    currentStack.transform[i] = props[i]
  }
  this.cArrPos += 1
  var newStack = this.stack[this.cArrPos]
  newStack.opacity = currentStack.opacity
  newStack.fillStyle = currentStack.fillStyle
  newStack.strokeStyle = currentStack.strokeStyle
  newStack.lineWidth = currentStack.lineWidth
  newStack.lineCap = currentStack.lineCap
  newStack.lineJoin = currentStack.lineJoin
  newStack.miterLimit = currentStack.miterLimit
};

CVContextData.prototype.setOpacity = function (value) {
  this.stack[this.cArrPos].opacity = value
};

CVContextData.prototype.setContext = function (value) {
  this.nativeContext = value
};

CVContextData.prototype.fillStyle = function (value) {
  if (this.stack[this.cArrPos].fillStyle !== value) {
    this.currentFillStyle = value
    this.stack[this.cArrPos].fillStyle = value
  }
}

CVContextData.prototype.strokeStyle = function (value) {
  if (this.stack[this.cArrPos].strokeStyle !== value) {
    this.currentStrokeStyle = value
    this.stack[this.cArrPos].strokeStyle = value
  }
}

CVContextData.prototype.lineWidth = function (value) {
  if (this.stack[this.cArrPos].lineWidth !== value) {
    this.currentLineWidth = value
    this.stack[this.cArrPos].lineWidth = value
  }
}

CVContextData.prototype.lineCap = function (value) {
  if (this.stack[this.cArrPos].lineCap !== value) {
    this.currentLineCap = value
    this.stack[this.cArrPos].lineCap = value
  }
}

CVContextData.prototype.lineJoin = function (value) {
  if (this.stack[this.cArrPos].lineJoin !== value) {
    this.currentLineJoin = value
    this.stack[this.cArrPos].lineJoin = value
  }
}

CVContextData.prototype.miterLimit = function (value) {
  if (this.stack[this.cArrPos].miterLimit !== value) {
    this.currentMiterLimit = value
    this.stack[this.cArrPos].miterLimit = value
  }
}

CVContextData.prototype.transform = function (props) {
  this.transformMat.cloneFromProps(props)
  // Taking the last transform value from the stored stack of transforms
  var currentTransform = this.cTr
  // Applying the last transform value after the new transform to respect the order of transformations
  this.transformMat.multiply(currentTransform)
  // Storing the new transformed value in the stored transform
  currentTransform.cloneFromProps(this.transformMat.props)
  var trProps = currentTransform.props
  // Applying the new transform to the canvas
  this.nativeContext.setTransform(
    trProps[0],
    trProps[1],
    trProps[4],
    trProps[5],
    trProps[12],
    trProps[13]
  )
}

CVContextData.prototype.opacity = function (op) {
  let currentOpacity = this.stack[this.cArrPos].opacity
  currentOpacity *= op < 0 ? 0 : op
  if (this.stack[this.cArrPos].opacity !== currentOpacity) {
    if (this.currentOpacity !== op) {
      this.nativeContext.globalAlpha = op
      this.currentOpacity = op
    }
    this.stack[this.cArrPos].opacity = currentOpacity
  }
}

CVContextData.prototype.fill = function (rule) {
  if (this.appliedFillStyle !== this.currentFillStyle) {
    this.appliedFillStyle = this.currentFillStyle
    this.nativeContext.fillStyle = this.appliedFillStyle
  }
  this.nativeContext.fill(rule)
};

CVContextData.prototype.fillRect = function (x, y, w, h) {
  if (this.appliedFillStyle !== this.currentFillStyle) {
    this.appliedFillStyle = this.currentFillStyle
    this.nativeContext.fillStyle = this.appliedFillStyle
  }
  this.nativeContext.fillRect(x, y, w, h)
};

CVContextData.prototype.stroke = function () {
  if (this.appliedStrokeStyle !== this.currentStrokeStyle) {
    this.appliedStrokeStyle = this.currentStrokeStyle
    this.nativeContext.strokeStyle = this.appliedStrokeStyle
  }
  if (this.appliedLineWidth !== this.currentLineWidth) {
    this.appliedLineWidth = this.currentLineWidth
    this.nativeContext.lineWidth = this.appliedLineWidth
  }
  if (this.appliedLineCap !== this.currentLineCap) {
    this.appliedLineCap = this.currentLineCap
    this.nativeContext.lineCap = this.appliedLineCap
  }
  if (this.appliedLineJoin !== this.currentLineJoin) {
    this.appliedLineJoin = this.currentLineJoin
    this.nativeContext.lineJoin = this.appliedLineJoin
  }
  if (this.appliedMiterLimit !== this.currentMiterLimit) {
    this.appliedMiterLimit = this.currentMiterLimit
    this.nativeContext.miterLimit = this.appliedMiterLimit
  }
  this.nativeContext.stroke()
};

function CVCompElement(data, globalData, comp) {
  this.completeLayers = false
  this.layers = data.layers
  this.pendingElements = []
  this.elements = createSizedArray(this.layers.length)
  this.initElement(data, globalData, comp)
  this.tm = data.tm
    ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this)
    : { _placeholder: true }
}

extendPrototype(
  [CanvasRendererBase, ICompElement, CVBaseElement],
  CVCompElement
)

CVCompElement.prototype.renderInnerContent = function () {
  let ctx = this.canvasContext
  ctx.beginPath()
  ctx.moveTo(0, 0)
  ctx.lineTo(this.data.w, 0)
  ctx.lineTo(this.data.w, this.data.h)
  ctx.lineTo(0, this.data.h)
  ctx.lineTo(0, 0)
  ctx.clip()
  var i
  var len = this.layers.length
  for (i = len - 1; i >= 0; i -= 1) {
    if (this.completeLayers || this.elements[i]) {
      this.elements[i].renderFrame()
    }
  }
}

CVCompElement.prototype.destroy = function () {
  let i
  var len = this.layers.length
  for (i = len - 1; i >= 0; i -= 1) {
    if (this.elements[i]) {
      this.elements[i].destroy()
    }
  }
  this.layers = null
  this.elements = null
};

CVCompElement.prototype.createComp = function (data) {
  return new CVCompElement(data, this.globalData, this)
};

function CanvasRenderer(animationItem, config) {
  this.animationItem = animationItem
  this.renderConfig = {
    className: (config && config.className) || '',
    clearCanvas: (config && config.clearCanvas !== undefined) ? config.clearCanvas : true,
    contentVisibility: (config && config.contentVisibility) || 'visible',
    context: (config && config.context) || null,
    id: (config && config.id) || '',
    imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',
    preserveAspectRatio: (config && config.preserveAspectRatio) || 'xMidYMid meet',
    progressiveLoad: (config && config.progressiveLoad) || false,
    runExpressions:
      !config || config.runExpressions === undefined || config.runExpressions,
  }
  this.renderConfig.dpr = (config && config.dpr) || 1
  if (this.animationItem.wrapper) {
    this.renderConfig.dpr =
      (config && config.dpr) || window.devicePixelRatio || 1
  }
  this.renderedFrame = -1
  this.globalData = {
    _mdf: false,
    currentGlobalAlpha: -1,
    frameNum: -1,
    renderConfig: this.renderConfig,
  }
  this.contextData = new CVContextData()
  this.elements = []
  this.pendingElements = []
  this.transformMat = new Matrix()
  this.completeLayers = false
  this.rendererType = 'canvas'
  if (this.renderConfig.clearCanvas) {
    this.ctxTransform = this.contextData.transform.bind(this.contextData)
    this.ctxOpacity = this.contextData.opacity.bind(this.contextData)
    this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData)
    this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData)
    this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData)
    this.ctxLineCap = this.contextData.lineCap.bind(this.contextData)
    this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData)
    this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData)
    this.ctxFill = this.contextData.fill.bind(this.contextData)
    this.ctxFillRect = this.contextData.fillRect.bind(this.contextData)
    this.ctxStroke = this.contextData.stroke.bind(this.contextData)
    this.save = this.contextData.save.bind(this.contextData)
  }
}
extendPrototype([CanvasRendererBase], CanvasRenderer)

CanvasRenderer.prototype.createComp = function (data) {
  return new CVCompElement(data, this.globalData, this)
};

function HBaseElement() {}
HBaseElement.prototype = {
  addEffects: function () {
  },
  checkBlendMode: function () {},
  createContainerElements: function () {
    this.renderableEffectsManager = new CVEffects(this);
    this.transformedElement = this.baseElement;
    this.maskedElement = this.layerElement;
    if (this.data.ln) {
      this.layerElement.setAttribute('id', this.data.ln);
    }
    if (this.data.cl) {
      this.layerElement.setAttribute('class', this.data.cl);
    }
    if (this.data.bm !== 0) {
      this.setBlendMode();
    }
  },
  createRenderableComponents: function () {
    this.maskManager = new MaskElement(this.data, this, this.globalData);
  },
  destroy: function () {
    this.layerElement = null;
    this.transformedElement = null;
    if (this.matteElement) {
      this.matteElement = null;
    }
    if (this.maskManager) {
      this.maskManager.destroy();
      this.maskManager = null;
    }
  },
  initRendererElement: function () {
    this.baseElement = createTag(this.data.tg || 'div');
    if (this.data.hasMask) {
      this.svgElement = createNS('svg');
      this.layerElement = createNS('g');
      this.maskedElement = this.layerElement;
      this.svgElement.appendChild(this.layerElement);
      this.baseElement.appendChild(this.svgElement);
    } else {
      this.layerElement = this.baseElement;
    }
    styleDiv(this.baseElement);
  },
  renderElement: function () {
    var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};
    if (this.finalTransform._matMdf) {
      var matrixValue = this.finalTransform.mat.toCSS();
      transformedElementStyle.transform = matrixValue;
      transformedElementStyle.webkitTransform = matrixValue;
    }
    if (this.finalTransform._opMdf) {
      transformedElementStyle.opacity = this.finalTransform.mProp.o.v;
    }
  },
  renderFrame: function () {
    // If it is exported as hidden (data.hd === true) no need to render
    // If it is not visible no need to render
    if (this.data.hd || this.hidden) {
      return;
    }
    this.renderTransform();
    this.renderRenderable();
    this.renderElement();
    this.renderInnerContent();
    if (this._isFirstFrame) {
      this._isFirstFrame = false;
    }
  },
  setMatte: function () {},
}
HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement
HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy
HBaseElement.prototype.buildElementParenting =
  BaseRenderer.prototype.buildElementParenting

function HSolidElement(data, globalData, comp) {
  this.initElement(data, globalData, comp)
}
extendPrototype(
  [
    BaseElement,
    TransformElement,
    HBaseElement,
    HierarchyElement,
    FrameElement,
    RenderableDOMElement,
  ],
  HSolidElement
)

HSolidElement.prototype.createContent = function () {
  let rect
  if (this.data.hasMask) {
    rect = createNS('rect')
    rect.setAttribute('width', this.data.sw)
    rect.setAttribute('height', this.data.sh)
    rect.setAttribute('fill', this.data.sc)
    this.svgElement.setAttribute('width', this.data.sw)
    this.svgElement.setAttribute('height', this.data.sh)
  } else {
    rect = createTag('div')
    rect.style.width = `${this.data.sw  }px`;
    rect.style.height = `${this.data.sh  }px`;
    rect.style.backgroundColor = this.data.sc
  }
  this.layerElement.appendChild(rect)
};

function HShapeElement(data, globalData, comp) {
  // List of drawable elements
  this.shapes = []
  // Full shape data
  this.shapesData = data.shapes
  // List of styles that will be applied to shapes
  this.stylesList = []
  // List of modifiers that will be applied to shapes
  this.shapeModifiers = []
  // List of items in shape tree
  this.itemsData = []
  // List of items in previous shape tree
  this.processedElements = []
  // List of animated components
  this.animatedContents = []
  this.shapesContainer = createNS('g')
  this.initElement(data, globalData, comp)
  // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
  // List of elements that have been created
  this.prevViewData = []
  this.currentBBox = {
    h: 0,
    w: 0,
    x: 999999,
    y: -999999,
  }
}
extendPrototype(
  [
    BaseElement,
    TransformElement,
    HSolidElement,
    SVGShapeElement,
    HBaseElement,
    HierarchyElement,
    FrameElement,
    RenderableElement,
  ],
  HShapeElement
)
HShapeElement.prototype._renderShapeFrame =
  HShapeElement.prototype.renderInnerContent

HShapeElement.prototype.createContent = function () {
  let cont
  this.baseElement.style.fontSize = 0
  if (this.data.hasMask) {
    this.layerElement.appendChild(this.shapesContainer)
    cont = this.svgElement
  } else {
    cont = createNS('svg')
    var size = this.comp.data ? this.comp.data : this.globalData.compSize
    cont.setAttribute('width', size.w)
    cont.setAttribute('height', size.h)
    cont.appendChild(this.shapesContainer)
    this.layerElement.appendChild(cont)
  }

  this.searchShapes(
    this.shapesData,
    this.itemsData,
    this.prevViewData,
    this.shapesContainer,
    0,
    [],
    true
  )
  this.filterUniqueShapes()
  this.shapeCont = cont
};

HShapeElement.prototype.getTransformedPoint = function (transformers, point) {
  let i
  var len = transformers.length
  for (i = 0; i < len; i += 1) {
    point = transformers[i].mProps.v.applyToPointArray(point[0], point[1], 0)
  }
  return point
};

HShapeElement.prototype.calculateShapeBoundingBox = function (
  item,
  boundingBox
) {
  let shape = item.sh.v
  var transformers = item.transformers
  var i
  var len = shape._length
  var vPoint
  var oPoint
  var nextIPoint
  var nextVPoint
  if (len <= 1) {
    return
  }
  for (i = 0; i < len - 1; i += 1) {
    vPoint = this.getTransformedPoint(transformers, shape.v[i])
    oPoint = this.getTransformedPoint(transformers, shape.o[i])
    nextIPoint = this.getTransformedPoint(transformers, shape.i[i + 1])
    nextVPoint = this.getTransformedPoint(transformers, shape.v[i + 1])
    this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox)
  }
  if (shape.c) {
    vPoint = this.getTransformedPoint(transformers, shape.v[i])
    oPoint = this.getTransformedPoint(transformers, shape.o[i])
    nextIPoint = this.getTransformedPoint(transformers, shape.i[0])
    nextVPoint = this.getTransformedPoint(transformers, shape.v[0])
    this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox)
  }
}

HShapeElement.prototype.checkBounds = function (
  vPoint,
  oPoint,
  nextIPoint,
  nextVPoint,
  boundingBox
) {
  this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint)
  var bounds = this.shapeBoundingBox
  boundingBox.x = bmMin(bounds.left, boundingBox.x)
  boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax)
  boundingBox.y = bmMin(bounds.top, boundingBox.y)
  boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax)
};

HShapeElement.prototype.shapeBoundingBox = {
  bottom: 0,
  left: 0,
  right: 0,
  top: 0,
}

HShapeElement.prototype.tempBoundingBox = {
  height: 0,
  width: 0,
  x: 0,
  xMax: 0,
  y: 0,
  yMax: 0,
}

HShapeElement.prototype.getBoundsOfCurve = function (p0, p1, p2, p3) {
  let bounds = [
    [p0[0], p3[0]],
    [p0[1], p3[1]],
  ]

  for (var a, b, c, t, b2ac, t1, t2, i = 0; i < 2; ++i) {
    // eslint-disable-line no-plusplus
    b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i]
    a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i]
    c = 3 * p1[i] - 3 * p0[i]

    b |= 0 // eslint-disable-line no-bitwise
    a |= 0 // eslint-disable-line no-bitwise
    c |= 0 // eslint-disable-line no-bitwise

    if (a === 0 && b === 0) {
      //
    } else if (a === 0) {
      t = -c / b

      if (t > 0 && t < 1) {
        bounds[i].push(this.calculateF(t, p0, p1, p2, p3, i))
      }
    } else {
      b2ac = b * b - 4 * c * a

      if (b2ac >= 0) {
        t1 = (-b + bmSqrt(b2ac)) / (2 * a)
        if (t1 > 0 && t1 < 1)
          bounds[i].push(this.calculateF(t1, p0, p1, p2, p3, i))
        t2 = (-b - bmSqrt(b2ac)) / (2 * a)
        if (t2 > 0 && t2 < 1)
          bounds[i].push(this.calculateF(t2, p0, p1, p2, p3, i))
      }
    }
  }

  this.shapeBoundingBox.left = bmMin.apply(null, bounds[0])
  this.shapeBoundingBox.top = bmMin.apply(null, bounds[1])
  this.shapeBoundingBox.right = bmMax.apply(null, bounds[0])
  this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1])
};

HShapeElement.prototype.calculateF = function (t, p0, p1, p2, p3, i) {
  return (
    bmPow(1 - t, 3) * p0[i] +
    3 * bmPow(1 - t, 2) * t * p1[i] +
    3 * (1 - t) * bmPow(t, 2) * p2[i] +
    bmPow(t, 3) * p3[i]
  )
}

HShapeElement.prototype.calculateBoundingBox = function (
  itemsData,
  boundingBox
) {
  let i
  var len = itemsData.length
  for (i = 0; i < len; i += 1) {
    if (itemsData[i] && itemsData[i].sh) {
      this.calculateShapeBoundingBox(itemsData[i], boundingBox)
    } else if (itemsData[i] && itemsData[i].it) {
      this.calculateBoundingBox(itemsData[i].it, boundingBox)
    } else if (itemsData[i] && itemsData[i].style && itemsData[i].w) {
      this.expandStrokeBoundingBox(itemsData[i].w, boundingBox)
    }
  }
}

HShapeElement.prototype.expandStrokeBoundingBox = function (
  widthProperty,
  boundingBox
) {
  let width = 0
  if (widthProperty.keyframes) {
    for (let i = 0; i < widthProperty.keyframes.length; i += 1) {
      let kfw = widthProperty.keyframes[i].s
      if (kfw > width) {
        width = kfw
      }
    }
    width *= widthProperty.mult
  } else {
    width = widthProperty.v * widthProperty.mult
  }

  boundingBox.x -= width
  boundingBox.xMax += width
  boundingBox.y -= width
  boundingBox.yMax += width
};

HShapeElement.prototype.currentBoxContains = function (box) {
  return (
    this.currentBBox.x <= box.x &&
    this.currentBBox.y <= box.y &&
    this.currentBBox.width + this.currentBBox.x >= box.x + box.width &&
    this.currentBBox.height + this.currentBBox.y >= box.y + box.height
  )
}

HShapeElement.prototype.renderInnerContent = function () {
  this._renderShapeFrame()

  if (!this.hidden && (this._isFirstFrame || this._mdf)) {
    let tempBoundingBox = this.tempBoundingBox
    var max = 999999
    tempBoundingBox.x = max
    tempBoundingBox.xMax = -max
    tempBoundingBox.y = max
    tempBoundingBox.yMax = -max
    this.calculateBoundingBox(this.itemsData, tempBoundingBox)
    tempBoundingBox.width =
      tempBoundingBox.xMax < tempBoundingBox.x
        ? 0
        : tempBoundingBox.xMax - tempBoundingBox.x
    tempBoundingBox.height =
      tempBoundingBox.yMax < tempBoundingBox.y
        ? 0
        : tempBoundingBox.yMax - tempBoundingBox.y
    // var tempBoundingBox = this.shapeCont.getBBox();
    if (this.currentBoxContains(tempBoundingBox)) {
      return
    }
    let changed = false
    if (this.currentBBox.w !== tempBoundingBox.width) {
      this.currentBBox.w = tempBoundingBox.width
      this.shapeCont.setAttribute('width', tempBoundingBox.width)
      changed = true
    }
    if (this.currentBBox.h !== tempBoundingBox.height) {
      this.currentBBox.h = tempBoundingBox.height
      this.shapeCont.setAttribute('height', tempBoundingBox.height)
      changed = true
    }
    if (
      changed ||
      this.currentBBox.x !== tempBoundingBox.x ||
      this.currentBBox.y !== tempBoundingBox.y
    ) {
      this.currentBBox.w = tempBoundingBox.width
      this.currentBBox.h = tempBoundingBox.height
      this.currentBBox.x = tempBoundingBox.x
      this.currentBBox.y = tempBoundingBox.y

      this.shapeCont.setAttribute(
        'viewBox',
        this.currentBBox.x +
          ' ' +
          this.currentBBox.y +
          ' ' +
          this.currentBBox.w +
          ' ' +
          this.currentBBox.h
      )
      let shapeStyle = this.shapeCont.style
      var shapeTransform =
        'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)'
      shapeStyle.transform = shapeTransform
      shapeStyle.webkitTransform = shapeTransform
    }
  }
}

function HTextElement(data, globalData, comp) {
  this.textSpans = []
  this.textPaths = []
  this.currentBBox = {
    h: 0,
    w: 0,
    x: 999999,
    y: -999999,
  }
  this.renderType = 'svg'
  this.isMasked = false
  this.initElement(data, globalData, comp)
}
extendPrototype(
  [
    BaseElement,
    TransformElement,
    HBaseElement,
    HierarchyElement,
    FrameElement,
    RenderableDOMElement,
    ITextElement,
  ],
  HTextElement
)

HTextElement.prototype.createContent = function () {
  this.isMasked = this.checkMasks()
  if (this.isMasked) {
    this.renderType = 'svg'
    this.compW = this.comp.data.w
    this.compH = this.comp.data.h
    this.svgElement.setAttribute('width', this.compW)
    this.svgElement.setAttribute('height', this.compH)
    var g = createNS('g')
    this.maskedElement.appendChild(g)
    this.innerElem = g
  } else {
    this.renderType = 'html'
    this.innerElem = this.layerElement
  }

  this.checkParenting()
};

HTextElement.prototype.buildNewText = function () {
  let documentData = this.textProperty.currentData
  this.renderedLetters = createSizedArray(
    documentData.l ? documentData.l.length : 0
  )
  let innerElemStyle = this.innerElem.style
  var textColor = documentData.fc
    ? this.buildColor(documentData.fc)
    : 'rgba(0,0,0,0)'
  innerElemStyle.fill = textColor
  innerElemStyle.color = textColor
  if (documentData.sc) {
    innerElemStyle.stroke = this.buildColor(documentData.sc)
    innerElemStyle.strokeWidth = `${documentData.sw  }px`;
  }
  let fontData = this.globalData.fontManager.getFontByName(documentData.f)
  if (!this.globalData.fontManager.chars) {
    innerElemStyle.fontSize = `${documentData.finalSize  }px`;
    innerElemStyle.lineHeight = `${documentData.finalSize  }px`;
    if (fontData.fClass) {
      this.innerElem.className = fontData.fClass
    } else {
      innerElemStyle.fontFamily = fontData.fFamily
      var fWeight = documentData.fWeight
      var fStyle = documentData.fStyle
      innerElemStyle.fontStyle = fStyle
      innerElemStyle.fontWeight = fWeight
    }
  }
  let i
  var len

  var letters = documentData.l
  len = letters.length
  var tSpan
  var tParent
  var tCont
  var matrixHelper = this.mHelper
  var shapes
  var shapeStr = ''
  var cnt = 0
  for (i = 0; i < len; i += 1) {
    if (this.globalData.fontManager.chars) {
      if (!this.textPaths[cnt]) {
        tSpan = createNS('path')
        tSpan.setAttribute('stroke-linecap', lineCapEnum[1])
        tSpan.setAttribute('stroke-linejoin', lineJoinEnum[2])
        tSpan.setAttribute('stroke-miterlimit', '4')
      } else {
        tSpan = this.textPaths[cnt]
      }
      if (!this.isMasked) {
        if (this.textSpans[cnt]) {
          tParent = this.textSpans[cnt]
          tCont = tParent.children[0]
        } else {
          tParent = createTag('div')
          tParent.style.lineHeight = 0
          tCont = createNS('svg')
          tCont.appendChild(tSpan)
          styleDiv(tParent)
        }
      }
    } else if (!this.isMasked) {
      if (this.textSpans[cnt]) {
        tParent = this.textSpans[cnt]
        tSpan = this.textPaths[cnt]
      } else {
        tParent = createTag('span')
        styleDiv(tParent)
        tSpan = createTag('span')
        styleDiv(tSpan)
        tParent.appendChild(tSpan)
      }
    } else {
      tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS('text')
    }
    // tSpan.setAttribute('visibility', 'hidden');
    if (this.globalData.fontManager.chars) {
      let charData = this.globalData.fontManager.getCharData(
        documentData.finalText[i],
        fontData.fStyle,
        this.globalData.fontManager.getFontByName(documentData.f).fFamily
      )
      var shapeData
      if (charData) {
        shapeData = charData.data
      } else {
        shapeData = null
      }
      matrixHelper.reset()
      if (shapeData && shapeData.shapes && shapeData.shapes.length) {
        shapes = shapeData.shapes[0].it
        matrixHelper.scale(
          documentData.finalSize / 100,
          documentData.finalSize / 100
        )
        shapeStr = this.createPathShape(matrixHelper, shapes)
        tSpan.setAttribute('d', shapeStr)
      }
      if (!this.isMasked) {
        this.innerElem.appendChild(tParent)
        if (shapeData && shapeData.shapes) {
          // document.body.appendChild is needed to get exact measure of shape
          document.body.appendChild(tCont)
          var boundingBox = tCont.getBBox()
          tCont.setAttribute('width', boundingBox.width + 2)
          tCont.setAttribute('height', boundingBox.height + 2)
          tCont.setAttribute(
            'viewBox',
            boundingBox.x -
              1 +
              ' ' +
              (boundingBox.y - 1) +
              ' ' +
              (boundingBox.width + 2) +
              ' ' +
              (boundingBox.height + 2)
          )
          let tContStyle = tCont.style
          var tContTranslation =
            'translate(' +
            (boundingBox.x - 1) +
            'px,' +
            (boundingBox.y - 1) +
            'px)'
          tContStyle.transform = tContTranslation
          tContStyle.webkitTransform = tContTranslation

          letters[i].yOffset = boundingBox.y - 1
        } else {
          tCont.setAttribute('width', 1)
          tCont.setAttribute('height', 1)
        }
        tParent.appendChild(tCont)
      } else {
        this.innerElem.appendChild(tSpan)
      }
    } else {
      tSpan.textContent = letters[i].val
      tSpan.setAttributeNS(
        'http://www.w3.org/XML/1998/namespace',
        'xml:space',
        'preserve'
      )
      if (!this.isMasked) {
        this.innerElem.appendChild(tParent)
        //
        var tStyle = tSpan.style
        var tSpanTranslation =
          'translate3d(0,' + -documentData.finalSize / 1.2 + 'px,0)'
        tStyle.transform = tSpanTranslation
        tStyle.webkitTransform = tSpanTranslation
      } else {
        this.innerElem.appendChild(tSpan)
      }
    }
    //
    if (!this.isMasked) {
      this.textSpans[cnt] = tParent
    } else {
      this.textSpans[cnt] = tSpan
    }
    this.textSpans[cnt].style.display = 'block'
    this.textPaths[cnt] = tSpan
    cnt += 1
  }
  while (cnt < this.textSpans.length) {
    this.textSpans[cnt].style.display = 'none'
    cnt += 1
  }
}

HTextElement.prototype.renderInnerContent = function () {
  this.validateText()
  var svgStyle
  if (this.data.singleShape) {
    if (!this._isFirstFrame && !this.lettersChangedFlag) {
      return
    } if (this.isMasked && this.finalTransform._matMdf) {
      // Todo Benchmark if using this is better than getBBox
      this.svgElement.setAttribute(
        'viewBox',
        -this.finalTransform.mProp.p.v[0] +
          ' ' +
          -this.finalTransform.mProp.p.v[1] +
          ' ' +
          this.compW +
          ' ' +
          this.compH
      )
      svgStyle = this.svgElement.style
      var translation =
        'translate(' +
        -this.finalTransform.mProp.p.v[0] +
        'px,' +
        -this.finalTransform.mProp.p.v[1] +
        'px)'
      svgStyle.transform = translation
      svgStyle.webkitTransform = translation
    }
  }

  this.textAnimator.getMeasures(
    this.textProperty.currentData,
    this.lettersChangedFlag
  )
  if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) {
    return
  }
  let i
  var len
  var count = 0
  var renderedLetters = this.textAnimator.renderedLetters

  var letters = this.textProperty.currentData.l

  len = letters.length
  var renderedLetter
  var textSpan
  var textPath
  for (i = 0; i < len; i += 1) {
    if (letters[i].n) {
      count += 1
    } else {
      textSpan = this.textSpans[i]
      textPath = this.textPaths[i]
      renderedLetter = renderedLetters[count]
      count += 1
      if (renderedLetter._mdf.m) {
        if (!this.isMasked) {
          textSpan.style.webkitTransform = renderedLetter.m
          textSpan.style.transform = renderedLetter.m
        } else {
          textSpan.setAttribute('transform', renderedLetter.m)
        }
      }
      // / /textSpan.setAttribute('opacity',renderedLetter.o);
      textSpan.style.opacity = renderedLetter.o
      if (renderedLetter.sw && renderedLetter._mdf.sw) {
        textPath.setAttribute('stroke-width', renderedLetter.sw)
      }
      if (renderedLetter.sc && renderedLetter._mdf.sc) {
        textPath.setAttribute('stroke', renderedLetter.sc)
      }
      if (renderedLetter.fc && renderedLetter._mdf.fc) {
        textPath.setAttribute('fill', renderedLetter.fc)
        textPath.style.color = renderedLetter.fc
      }
    }
  }

  if (
    this.innerElem.getBBox &&
    !this.hidden &&
    (this._isFirstFrame || this._mdf)
  ) {
    let boundingBox = this.innerElem.getBBox()

    if (this.currentBBox.w !== boundingBox.width) {
      this.currentBBox.w = boundingBox.width
      this.svgElement.setAttribute('width', boundingBox.width)
    }
    if (this.currentBBox.h !== boundingBox.height) {
      this.currentBBox.h = boundingBox.height
      this.svgElement.setAttribute('height', boundingBox.height)
    }

    let margin = 1
    if (
      this.currentBBox.w !== boundingBox.width + margin * 2 ||
      this.currentBBox.h !== boundingBox.height + margin * 2 ||
      this.currentBBox.x !== boundingBox.x - margin ||
      this.currentBBox.y !== boundingBox.y - margin
    ) {
      this.currentBBox.w = boundingBox.width + margin * 2
      this.currentBBox.h = boundingBox.height + margin * 2
      this.currentBBox.x = boundingBox.x - margin
      this.currentBBox.y = boundingBox.y - margin

      this.svgElement.setAttribute(
        'viewBox',
        this.currentBBox.x +
          ' ' +
          this.currentBBox.y +
          ' ' +
          this.currentBBox.w +
          ' ' +
          this.currentBBox.h
      )
      svgStyle = this.svgElement.style
      var svgTransform =
        'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)'
      svgStyle.transform = svgTransform
      svgStyle.webkitTransform = svgTransform
    }
  }
}

function HCameraElement(data, globalData, comp) {
  this.initFrame()
  this.initBaseData(data, globalData, comp)
  this.initHierarchy()
  var getProp = PropertyFactory.getProp
  this.pe = getProp(this, data.pe, 0, 0, this)
  if (data.ks.p.s) {
    this.px = getProp(this, data.ks.p.x, 1, 0, this)
    this.py = getProp(this, data.ks.p.y, 1, 0, this)
    this.pz = getProp(this, data.ks.p.z, 1, 0, this)
  } else {
    this.p = getProp(this, data.ks.p, 1, 0, this)
  }
  if (data.ks.a) {
    this.a = getProp(this, data.ks.a, 1, 0, this)
  }
  if (data.ks.or.k.length && data.ks.or.k[0].to) {
    let i
    var len = data.ks.or.k.length
    for (i = 0; i < len; i += 1) {
      data.ks.or.k[i].to = null
      data.ks.or.k[i].ti = null
    }
  }
  this.or = getProp(this, data.ks.or, 1, degToRads, this)
  this.or.sh = true
  this.rx = getProp(this, data.ks.rx, 0, degToRads, this)
  this.ry = getProp(this, data.ks.ry, 0, degToRads, this)
  this.rz = getProp(this, data.ks.rz, 0, degToRads, this)
  this.mat = new Matrix()
  this._prevMat = new Matrix()
  this._isFirstFrame = true

  // TODO: find a better way to make the HCamera element to be compatible with the LayerInterface and TransformInterface.
  this.finalTransform = {
    mProp: this,
  }
}
extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement)

HCameraElement.prototype.setup = function () {
  let i
  var len = this.comp.threeDElements.length
  var comp
  var perspectiveStyle
  var containerStyle
  for (i = 0; i < len; i += 1) {
    // [perspectiveElem,container]
    comp = this.comp.threeDElements[i]
    if (comp.type === '3d') {
      perspectiveStyle = comp.perspectiveElem.style
      containerStyle = comp.container.style
      var perspective = `${this.pe.v  }px`;
      let origin = '0px 0px 0px'
      var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)'
      perspectiveStyle.perspective = perspective
      perspectiveStyle.webkitPerspective = perspective
      containerStyle.transformOrigin = origin
      containerStyle.mozTransformOrigin = origin
      containerStyle.webkitTransformOrigin = origin
      perspectiveStyle.transform = matrix
      perspectiveStyle.webkitTransform = matrix
    }
  }
}

HCameraElement.prototype.createElements = function () {}

HCameraElement.prototype.hide = function () {}

HCameraElement.prototype.renderFrame = function () {
  let _mdf = this._isFirstFrame
  var i
  var len
  if (this.hierarchy) {
    len = this.hierarchy.length
    for (i = 0; i < len; i += 1) {
      _mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf
    }
  }
  if (
    _mdf ||
    this.pe._mdf ||
    (this.p && this.p._mdf) ||
    (this.px && (this.px._mdf || this.py._mdf || this.pz._mdf)) ||
    this.rx._mdf ||
    this.ry._mdf ||
    this.rz._mdf ||
    this.or._mdf ||
    (this.a && this.a._mdf)
  ) {
    this.mat.reset()

    if (this.hierarchy) {
      len = this.hierarchy.length - 1
      for (i = len; i >= 0; i -= 1) {
        let mTransf = this.hierarchy[i].finalTransform.mProp
        this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2])
        this.mat
          .rotateX(-mTransf.or.v[0])
          .rotateY(-mTransf.or.v[1])
          .rotateZ(mTransf.or.v[2])
        this.mat
          .rotateX(-mTransf.rx.v)
          .rotateY(-mTransf.ry.v)
          .rotateZ(mTransf.rz.v)
        this.mat.scale(
          1 / mTransf.s.v[0],
          1 / mTransf.s.v[1],
          1 / mTransf.s.v[2]
        )
        this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2])
      }
    }
    if (this.p) {
      this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2])
    } else {
      this.mat.translate(-this.px.v, -this.py.v, this.pz.v)
    }
    if (this.a) {
      let diffVector
      if (this.p) {
        diffVector = [
          this.p.v[0] - this.a.v[0],
          this.p.v[1] - this.a.v[1],
          this.p.v[2] - this.a.v[2],
        ]
      } else {
        diffVector = [
          this.px.v - this.a.v[0],
          this.py.v - this.a.v[1],
          this.pz.v - this.a.v[2],
        ]
      }
      let mag = Math.sqrt(
        Math.pow(diffVector[0], 2) +
          Math.pow(diffVector[1], 2) +
          Math.pow(diffVector[2], 2)
      )
      // var lookDir = getNormalizedPoint(getDiffVector(this.a.v,this.p.v));
      let lookDir = [
        diffVector[0] / mag,
        diffVector[1] / mag,
        diffVector[2] / mag,
      ]
      let lookLengthOnXZ = Math.sqrt(
        lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]
      )
      let mRotationX = Math.atan2(lookDir[1], lookLengthOnXZ)
      let mRotationY = Math.atan2(lookDir[0], -lookDir[2])
      this.mat.rotateY(mRotationY).rotateX(-mRotationX)
    }
    this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v)
    this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2])
    this.mat.translate(
      this.globalData.compSize.w / 2,
      this.globalData.compSize.h / 2,
      0
    )
    this.mat.translate(0, 0, this.pe.v)

    var hasMatrixChanged = !this._prevMat.equals(this.mat)
    if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {
      len = this.comp.threeDElements.length
      var comp
      var perspectiveStyle
      var containerStyle
      for (i = 0; i < len; i += 1) {
        comp = this.comp.threeDElements[i]
        if (comp.type === '3d') {
          if (hasMatrixChanged) {
            let matValue = this.mat.toCSS()
            containerStyle = comp.container.style
            containerStyle.transform = matValue
            containerStyle.webkitTransform = matValue
          }
          if (this.pe._mdf) {
            perspectiveStyle = comp.perspectiveElem.style
            perspectiveStyle.perspective = `${this.pe.v  }px`;
            perspectiveStyle.webkitPerspective = `${this.pe.v  }px`;
          }
        }
      }
      this.mat.clone(this._prevMat)
    }
  }
  this._isFirstFrame = false
};

HCameraElement.prototype.prepareFrame = function (num) {
  this.prepareProperties(num, true)
};

HCameraElement.prototype.destroy = function () {}
HCameraElement.prototype.getBaseElement = function () {
  return null
}

function HImageElement(data, globalData, comp) {
  this.assetData = globalData.getAssetData(data.refId)
  this.initElement(data, globalData, comp)
}

extendPrototype(
  [
    BaseElement,
    TransformElement,
    HBaseElement,
    HSolidElement,
    HierarchyElement,
    FrameElement,
    RenderableElement,
  ],
  HImageElement
)

HImageElement.prototype.createContent = function () {
  let assetPath = this.globalData.getAssetsPath(this.assetData)
  var img = new Image()

  if (this.data.hasMask) {
    this.imageElem = createNS('image')
    this.imageElem.setAttribute('width', `${this.assetData.w  }px`)
    this.imageElem.setAttribute('height', `${this.assetData.h  }px`)
    this.imageElem.setAttributeNS(
      'http://www.w3.org/1999/xlink',
      'href',
      assetPath
    )
    this.layerElement.appendChild(this.imageElem)
    this.baseElement.setAttribute('width', this.assetData.w)
    this.baseElement.setAttribute('height', this.assetData.h)
  } else {
    this.layerElement.appendChild(img)
  }
  img.crossOrigin = 'anonymous'
  img.src = assetPath
  if (this.data.ln) {
    this.baseElement.setAttribute('id', this.data.ln)
  }
}

function HybridRendererBase(animationItem, config) {
  this.animationItem = animationItem
  this.layers = null
  this.renderedFrame = -1
  this.renderConfig = {
    className: (config && config.className) || '',
    filterSize: {
      width: (config && config.filterSize && config.filterSize.width) || '400%',
      height: (config && config.filterSize && config.filterSize.height) || '400%',
      x: (config && config.filterSize && config.filterSize.x) || '-100%',
      y: (config && config.filterSize && config.filterSize.y) || '-100%',
    },
    hideOnTransparent: !(config && config.hideOnTransparent === false),
    imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',
  }
  this.globalData = {
    _mdf: false,
    frameNum: -1,
    renderConfig: this.renderConfig,
  }
  this.pendingElements = []
  this.elements = []
  this.threeDElements = []
  this.destroyed = false
  this.camera = null
  this.supports3d = true
  this.rendererType = 'html'
}

extendPrototype([BaseRenderer], HybridRendererBase)

HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem

HybridRendererBase.prototype.checkPendingElements = function () {
  while (this.pendingElements.length) {
    let element = this.pendingElements.pop()
    element.checkParenting()
  }
}

HybridRendererBase.prototype.appendElementInPos = function (element, pos) {
  let newDOMElement = element.getBaseElement()
  if (!newDOMElement) {
    return
  }
  let layer = this.layers[pos]
  if (!layer.ddd || !this.supports3d) {
    if (this.threeDElements) {
      this.addTo3dContainer(newDOMElement, pos)
    } else {
      let i = 0
      var nextDOMElement
      var nextLayer
      var tmpDOMElement
      while (i < pos) {
        if (
          this.elements[i] &&
          this.elements[i] !== true &&
          this.elements[i].getBaseElement
        ) {
          nextLayer = this.elements[i]
          tmpDOMElement = this.layers[i].ddd
            ? this.getThreeDContainerByPos(i)
            : nextLayer.getBaseElement()
          nextDOMElement = tmpDOMElement || nextDOMElement
        }
        i += 1
      }
      if (nextDOMElement) {
        if (!layer.ddd || !this.supports3d) {
          this.layerElement.insertBefore(newDOMElement, nextDOMElement)
        }
      } else if (!layer.ddd || !this.supports3d) {
        this.layerElement.appendChild(newDOMElement)
      }
    }
  } else {
    this.addTo3dContainer(newDOMElement, pos)
  }
}

HybridRendererBase.prototype.createShape = function (data) {
  if (!this.supports3d) {
    return new SVGShapeElement(data, this.globalData, this)
  }
  return new HShapeElement(data, this.globalData, this)
};

HybridRendererBase.prototype.createText = function (data) {
  if (!this.supports3d) {
    return new SVGTextLottieElement(data, this.globalData, this)
  }
  return new HTextElement(data, this.globalData, this)
};

HybridRendererBase.prototype.createCamera = function (data) {
  this.camera = new HCameraElement(data, this.globalData, this)
  return this.camera
};

HybridRendererBase.prototype.createImage = function (data) {
  if (!this.supports3d) {
    return new IImageElement(data, this.globalData, this)
  }
  return new HImageElement(data, this.globalData, this)
};

HybridRendererBase.prototype.createSolid = function (data) {
  if (!this.supports3d) {
    return new ISolidElement(data, this.globalData, this)
  }
  return new HSolidElement(data, this.globalData, this)
};

HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull

HybridRendererBase.prototype.getThreeDContainerByPos = function (pos) {
  let i = 0
  var len = this.threeDElements.length
  while (i < len) {
    if (
      this.threeDElements[i].startPos <= pos &&
      this.threeDElements[i].endPos >= pos
    ) {
      return this.threeDElements[i].perspectiveElem
    }
    i += 1
  }
  return null
};

HybridRendererBase.prototype.createThreeDContainer = function (pos, type) {
  let perspectiveElem = createTag('div')
  var style
  var containerStyle
  styleDiv(perspectiveElem)
  var container = createTag('div')
  styleDiv(container)
  if (type === '3d') {
    style = perspectiveElem.style
    style.width = `${this.globalData.compSize.w  }px`;
    style.height = `${this.globalData.compSize.h  }px`;
    let center = '50% 50%'
    style.webkitTransformOrigin = center
    style.mozTransformOrigin = center
    style.transformOrigin = center
    containerStyle = container.style
    var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)'
    containerStyle.transform = matrix
    containerStyle.webkitTransform = matrix
  }

  perspectiveElem.appendChild(container)
  // this.resizerElem.appendChild(perspectiveElem);
  var threeDContainerData = {
    container: container,
    endPos: pos,
    perspectiveElem: perspectiveElem,
    startPos: pos,
    type: type,
  }
  this.threeDElements.push(threeDContainerData)
  return threeDContainerData
};

HybridRendererBase.prototype.build3dContainers = function () {
  let i
  var len = this.layers.length
  var lastThreeDContainerData
  var currentContainer = ''
  for (i = 0; i < len; i += 1) {
    if (this.layers[i].ddd && this.layers[i].ty !== 3) {
      if (currentContainer !== '3d') {
        currentContainer = '3d'
        lastThreeDContainerData = this.createThreeDContainer(i, '3d')
      }
      lastThreeDContainerData.endPos = Math.max(
        lastThreeDContainerData.endPos,
        i
      )
    } else {
      if (currentContainer !== '2d') {
        currentContainer = '2d'
        lastThreeDContainerData = this.createThreeDContainer(i, '2d')
      }
      lastThreeDContainerData.endPos = Math.max(
        lastThreeDContainerData.endPos,
        i
      )
    }
  }
  len = this.threeDElements.length
  for (i = len - 1; i >= 0; i -= 1) {
    this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem)
  }
}

HybridRendererBase.prototype.addTo3dContainer = function (elem, pos) {
  let i = 0
  var len = this.threeDElements.length
  while (i < len) {
    if (pos <= this.threeDElements[i].endPos) {
      let j = this.threeDElements[i].startPos
      var nextElement
      while (j < pos) {
        if (this.elements[j] && this.elements[j].getBaseElement) {
          nextElement = this.elements[j].getBaseElement()
        }
        j += 1
      }
      if (nextElement) {
        this.threeDElements[i].container.insertBefore(elem, nextElement)
      } else {
        this.threeDElements[i].container.appendChild(elem)
      }
      break
    }
    i += 1
  }
}

HybridRendererBase.prototype.configAnimation = function (animData) {
  let resizerElem = createTag('div')
  var wrapper = this.animationItem.wrapper
  var style = resizerElem.style
  style.width = `${animData.w  }px`;
  style.height = `${animData.h  }px`;
  this.resizerElem = resizerElem
  styleDiv(resizerElem)
  style.transformStyle = 'flat'
  style.mozTransformStyle = 'flat'
  style.webkitTransformStyle = 'flat'
  if (this.renderConfig.className) {
    resizerElem.setAttribute('class', this.renderConfig.className)
  }
  wrapper.appendChild(resizerElem)

  style.overflow = 'hidden'
  var svg = createNS('svg')
  svg.setAttribute('width', '1')
  svg.setAttribute('height', '1')
  styleDiv(svg)
  this.resizerElem.appendChild(svg)
  var defs = createNS('defs')
  svg.appendChild(defs)
  this.data = animData
  // Mask animation
  this.setupGlobalData(animData, svg)
  this.globalData.defs = defs
  this.layers = animData.layers
  this.layerElement = this.resizerElem
  this.build3dContainers()
  this.updateContainerSize()
};

HybridRendererBase.prototype.destroy = function () {
  if (this.animationItem.wrapper) {
    this.animationItem.wrapper.innerText = ''
  }
  this.animationItem.container = null
  this.globalData.defs = null
  var i
  var len = this.layers ? this.layers.length : 0
  for (i = 0; i < len; i += 1) {
    if (this.elements[i] && this.elements[i].destroy) {
      this.elements[i].destroy()
    }
  }
  this.elements.length = 0
  this.destroyed = true
  this.animationItem = null
};

HybridRendererBase.prototype.updateContainerSize = function () {
  let elementWidth = this.animationItem.wrapper.offsetWidth
  var elementHeight = this.animationItem.wrapper.offsetHeight
  var elementRel = elementWidth / elementHeight
  var animationRel = this.globalData.compSize.w / this.globalData.compSize.h
  var sx
  var sy
  var tx
  var ty
  if (animationRel > elementRel) {
    sx = elementWidth / this.globalData.compSize.w
    sy = elementWidth / this.globalData.compSize.w
    tx = 0
    ty =
      (elementHeight -
        this.globalData.compSize.h *
          (elementWidth / this.globalData.compSize.w)) /
      2
  } else {
    sx = elementHeight / this.globalData.compSize.h
    sy = elementHeight / this.globalData.compSize.h
    tx =
      (elementWidth -
        this.globalData.compSize.w *
          (elementHeight / this.globalData.compSize.h)) /
      2
    ty = 0
  }
  let style = this.resizerElem.style
  style.webkitTransform =
    'matrix3d(' +
    sx +
    ',0,0,0,0,' +
    sy +
    ',0,0,0,0,1,0,' +
    tx +
    ',' +
    ty +
    ',0,1)'
  style.transform = style.webkitTransform
};

HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame

HybridRendererBase.prototype.hide = function () {
  this.resizerElem.style.display = 'none'
};

HybridRendererBase.prototype.show = function () {
  this.resizerElem.style.display = 'block'
};

HybridRendererBase.prototype.initItems = function () {
  this.buildAllItems()
  if (this.camera) {
    this.camera.setup()
  } else {
    let cWidth = this.globalData.compSize.w
    var cHeight = this.globalData.compSize.h
    var i
    var len = this.threeDElements.length
    for (i = 0; i < len; i += 1) {
      let style = this.threeDElements[i].perspectiveElem.style
      style.webkitPerspective =
        Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + 'px'
      style.perspective = style.webkitPerspective
    }
  }
}

HybridRendererBase.prototype.searchExtraCompositions = function (assets) {
  let i
  var len = assets.length
  var floatingContainer = createTag('div')
  for (i = 0; i < len; i += 1) {
    if (assets[i].xt) {
      let comp = this.createComp(
        assets[i],
        floatingContainer,
        this.globalData.comp,
        null
      )
      comp.initExpressions()
      this.globalData.projectInterface.registerComposition(comp)
    }
  }
}

function HCompElement(data, globalData, comp) {
  this.layers = data.layers
  this.supports3d = !data.hasMask
  this.completeLayers = false
  this.pendingElements = []
  this.elements = this.layers ? createSizedArray(this.layers.length) : []
  this.initElement(data, globalData, comp)
  this.tm = data.tm
    ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this)
    : { _placeholder: true }
}

extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement)
HCompElement.prototype._createBaseContainerElements =
  HCompElement.prototype.createContainerElements

HCompElement.prototype.createContainerElements = function () {
  this._createBaseContainerElements()
  // divElement.style.clip = 'rect(0px, '+this.data.w+'px, '+this.data.h+'px, 0px)';
  if (this.data.hasMask) {
    this.svgElement.setAttribute('width', this.data.w)
    this.svgElement.setAttribute('height', this.data.h)
    this.transformedElement = this.baseElement
  } else {
    this.transformedElement = this.layerElement
  }
}

HCompElement.prototype.addTo3dContainer = function (elem, pos) {
  let j = 0
  var nextElement
  while (j < pos) {
    if (this.elements[j] && this.elements[j].getBaseElement) {
      nextElement = this.elements[j].getBaseElement()
    }
    j += 1
  }
  if (nextElement) {
    this.layerElement.insertBefore(elem, nextElement)
  } else {
    this.layerElement.appendChild(elem)
  }
}

HCompElement.prototype.createComp = function (data) {
  if (!this.supports3d) {
    return new SVGCompElement(data, this.globalData, this)
  }
  return new HCompElement(data, this.globalData, this)
};

function HybridRenderer(animationItem, config) {
  this.animationItem = animationItem
  this.layers = null
  this.renderedFrame = -1
  this.renderConfig = {
    className: (config && config.className) || '',
    filterSize: {
      width: (config && config.filterSize && config.filterSize.width) || '400%',
      height: (config && config.filterSize && config.filterSize.height) || '400%',
      x: (config && config.filterSize && config.filterSize.x) || '-100%',
      y: (config && config.filterSize && config.filterSize.y) || '-100%',
    },
    hideOnTransparent: !(config && config.hideOnTransparent === false),
    imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',
    runExpressions:
      !config || config.runExpressions === undefined || config.runExpressions,
  }
  this.globalData = {
    _mdf: false,
    frameNum: -1,
    renderConfig: this.renderConfig,
  }
  this.pendingElements = []
  this.elements = []
  this.threeDElements = []
  this.destroyed = false
  this.camera = null
  this.supports3d = true
  this.rendererType = 'html'
}

extendPrototype([HybridRendererBase], HybridRenderer)

HybridRenderer.prototype.createComp = function (data) {
  if (!this.supports3d) {
    return new SVGCompElement(data, this.globalData, this)
  }
  return new HCompElement(data, this.globalData, this)
};

const CompExpressionInterface = (function () {
  return function (comp) {
    function _thisLayerFunction(name) {
      let i = 0
      var len = comp.layers.length
      while (i < len) {
        if (comp.layers[i].nm === name || comp.layers[i].ind === name) {
          return comp.elements[i].layerInterface
        }
        i += 1
      }
      return null
      // return {active:false};
    }
    Object.defineProperty(_thisLayerFunction, '_name', { value: comp.data.nm })
    _thisLayerFunction.layer = _thisLayerFunction
    _thisLayerFunction.pixelAspect = 1
    _thisLayerFunction.height = comp.data.h || comp.globalData.compSize.h
    _thisLayerFunction.width = comp.data.w || comp.globalData.compSize.w
    _thisLayerFunction.pixelAspect = 1
    _thisLayerFunction.frameDuration = 1 / comp.globalData.frameRate
    _thisLayerFunction.displayStartTime = 0
    _thisLayerFunction.numLayers = comp.layers.length
    return _thisLayerFunction
  };
})();

/* eslint-disable */
/*
 Copyright 2014 David Bau.

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 */

function seedRandom(pool, math) {
//
// The following constants are related to IEEE 754 limits.
//
    var global = this,
        width = 256,        // each RC4 output is 0 <= x < 256
        chunks = 6,         // at least six RC4 outputs for each double
        digits = 52,        // there are 52 significant digits in a double
        rngname = 'random', // rngname: name for Math.random and Math.seedrandom
        startdenom = math.pow(width, chunks),
        significance = math.pow(2, digits),
        overflow = significance * 2,
        mask = width - 1,
        nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
    function seedrandom(seed, options, callback) {
        var key = [];
        options = (options === true) ? { entropy: true } : (options || {});

        // Flatten the seed string or build one from local entropy if needed.
        var shortseed = mixkey(flatten(
            options.entropy ? [seed, tostring(pool)] :
                (seed === null) ? autoseed() : seed, 3), key);

        // Use the seed to initialize an ARC4 generator.
        var arc4 = new ARC4(key);

        // This function returns a random double in [0, 1) that contains
        // randomness in every bit of the mantissa of the IEEE 754 value.
        var prng = function() {
            var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
                d = startdenom,                 //   and denominator d = 2 ^ 48.
                x = 0;                          //   and no 'extra last byte'.
            while (n < significance) {          // Fill up all significant digits by
                n = (n + x) * width;              //   shifting numerator and
                d *= width;                       //   denominator and generating a
                x = arc4.g(1);                    //   new least-significant-byte.
            }
            while (n >= overflow) {             // To avoid rounding up, before adding
                n /= 2;                           //   last byte, shift everything
                d /= 2;                           //   right using integer math until
                x >>>= 1;                         //   we have exactly the desired bits.
            }
            return (n + x) / d;                 // Form the number within [0, 1).
        };

        prng.int32 = function() { return arc4.g(4) | 0; };
        prng.quick = function() { return arc4.g(4) / 0x100000000; };
        prng.double = prng;

        // Mix the randomness into accumulated entropy.
        mixkey(tostring(arc4.S), pool);

        // Calling convention: what to return as a function of prng, seed, is_math.
        return (options.pass || callback ||
        function(prng, seed, is_math_call, state) {
            if (state) {
                // Load the arc4 state from the given state if it has an S array.
                if (state.S) { copy(state, arc4); }
                // Only provide the .state method if requested via options.state.
                prng.state = function() { return copy(arc4, {}); };
            }

            // If called as a method of Math (Math.seedrandom()), mutate
            // Math.random because that is how seedrandom.js has worked since v1.0.
            if (is_math_call) { math[rngname] = prng; return seed; }

            // Otherwise, it is a newer calling convention, so return the
            // prng directly.
            else return prng;
        })(
            prng,
            shortseed,
            'global' in options ? options.global : (this == math),
            options.state);
    }
    math['seed' + rngname] = seedrandom;

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
    function ARC4(key) {
        var t, keylen = key.length,
            me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

        // The empty key [] is treated as [0].
        if (!keylen) { key = [keylen++]; }

        // Set up S using the standard key scheduling algorithm.
        while (i < width) {
            s[i] = i++;
        }
        for (i = 0; i < width; i++) {
            s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
            s[j] = t;
        }

        // The "g" method returns the next (count) outputs as one number.
        me.g = function(count) {
            // Using instance members instead of closure state nearly doubles speed.
            var t, r = 0,
                i = me.i, j = me.j, s = me.S;
            while (count--) {
                t = s[i = mask & (i + 1)];
                r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
            }
            me.i = i; me.j = j;
            return r;
            // For robust unpredictability, the function call below automatically
            // discards an initial batch of values.  This is called RC4-drop[256].
            // See http://google.com/search?q=rsa+fluhrer+response&btnI
        };
    }

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
    function copy(f, t) {
        t.i = f.i;
        t.j = f.j;
        t.S = f.S.slice();
        return t;
    }

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
    function flatten(obj, depth) {
        var result = [], typ = (typeof obj), prop;
        if (depth && typ == 'object') {
            for (prop in obj) {
                try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
            }
        }
        return (result.length ? result : typ == 'string' ? obj : obj + '\0');
    }

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
    function mixkey(seed, key) {
        var stringseed = seed + '', smear, j = 0;
        while (j < stringseed.length) {
            key[mask & j] =
                mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
        }
        return tostring(key);
    }

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
    function autoseed() {
        try {
            if (nodecrypto) { return tostring(nodecrypto.randomBytes(width)); }
            var out = new Uint8Array(width);
            (global.crypto || global.msCrypto).getRandomValues(out);
            return tostring(out);
        } catch (e) {
            var browser = global.navigator,
                plugins = browser && browser.plugins;
            return [+new Date(), global, plugins, global.screen, tostring(pool)];
        }
    }

//
// tostring()
// Converts an array of charcodes to a string
//
    function tostring(a) {
        return String.fromCharCode.apply(0, a);
    }

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
    mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//

// End anonymous scope, and pass initial values.
};

function initialize$2(BMMath) {
    seedRandom([], BMMath);
}

var propTypes = {
  SHAPE: 'shape',
};

 

const ExpressionManager = (function () {
  'use strict';

  var ob = {};
  var Math = BMMath;
  var window = null;
  var document = null;
  var XMLHttpRequest = null;
  var fetch = null;
  var frames = null;
  var _lottieGlobal = {};
  initialize$2(BMMath);

  function resetFrame() {
    _lottieGlobal = {};
  }

  function $bm_isInstanceOfArray(arr) {
    return arr.constructor === Array || arr.constructor === Float32Array;
  }

  function isNumerable(tOfV, v) {
    return tOfV === 'number' || v instanceof Number || tOfV === 'boolean' || tOfV === 'string';
  }

  function $bm_neg(a) {
    var tOfA = typeof a;
    if (tOfA === 'number' || a instanceof Number || tOfA === 'boolean') {
      return -a;
    }
    if ($bm_isInstanceOfArray(a)) {
      var i;
      var lenA = a.length;
      var retArr = [];
      for (i = 0; i < lenA; i += 1) {
        retArr[i] = -a[i];
      }
      return retArr;
    }
    if (a.propType) {
      return a.v;
    }
    return -a;
  }

  var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, 'easeIn').get;
  var easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, 'easeOut').get;
  var easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, 'easeInOut').get;

  function sum(a, b) {
    var tOfA = typeof a;
    var tOfB = typeof b;
    if ((isNumerable(tOfA, a) && isNumerable(tOfB, b)) || tOfA === 'string' || tOfB === 'string') {
      return a + b;
    }
    if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
      a = a.slice(0);
      a[0] += b;
      return a;
    }
    if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
      b = b.slice(0);
      b[0] = a + b[0];
      return b;
    }
    if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
      var i = 0;
      var lenA = a.length;
      var lenB = b.length;
      var retArr = [];
      while (i < lenA || i < lenB) {
        if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {
          retArr[i] = a[i] + b[i];
        } else {
          retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
        }
        i += 1;
      }
      return retArr;
    }
    return 0;
  }
  var add = sum;

  function sub(a, b) {
    var tOfA = typeof a;
    var tOfB = typeof b;
    if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
      if (tOfA === 'string') {
        a = parseInt(a, 10);
      }
      if (tOfB === 'string') {
        b = parseInt(b, 10);
      }
      return a - b;
    }
    if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
      a = a.slice(0);
      a[0] -= b;
      return a;
    }
    if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
      b = b.slice(0);
      b[0] = a - b[0];
      return b;
    }
    if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
      var i = 0;
      var lenA = a.length;
      var lenB = b.length;
      var retArr = [];
      while (i < lenA || i < lenB) {
        if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {
          retArr[i] = a[i] - b[i];
        } else {
          retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
        }
        i += 1;
      }
      return retArr;
    }
    return 0;
  }

  function mul(a, b) {
    var tOfA = typeof a;
    var tOfB = typeof b;
    var arr;
    if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
      return a * b;
    }

    var i;
    var len;
    if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
      len = a.length;
      arr = createTypedArray('float32', len);
      for (i = 0; i < len; i += 1) {
        arr[i] = a[i] * b;
      }
      return arr;
    }
    if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
      len = b.length;
      arr = createTypedArray('float32', len);
      for (i = 0; i < len; i += 1) {
        arr[i] = a * b[i];
      }
      return arr;
    }
    return 0;
  }

  function div(a, b) {
    var tOfA = typeof a;
    var tOfB = typeof b;
    var arr;
    if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
      return a / b;
    }
    var i;
    var len;
    if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
      len = a.length;
      arr = createTypedArray('float32', len);
      for (i = 0; i < len; i += 1) {
        arr[i] = a[i] / b;
      }
      return arr;
    }
    if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
      len = b.length;
      arr = createTypedArray('float32', len);
      for (i = 0; i < len; i += 1) {
        arr[i] = a / b[i];
      }
      return arr;
    }
    return 0;
  }
  function mod(a, b) {
    if (typeof a === 'string') {
      a = parseInt(a, 10);
    }
    if (typeof b === 'string') {
      b = parseInt(b, 10);
    }
    return a % b;
  }
  var $bm_sum = sum;
  var $bm_sub = sub;
  var $bm_mul = mul;
  var $bm_div = div;
  var $bm_mod = mod;

  function clamp(num, min, max) {
    if (min > max) {
      var mm = max;
      max = min;
      min = mm;
    }
    return Math.min(Math.max(num, min), max);
  }

  function radiansToDegrees(val) {
    return val / degToRads;
  }
  var radians_to_degrees = radiansToDegrees;

  function degreesToRadians(val) {
    return val * degToRads;
  }
  var degrees_to_radians = radiansToDegrees;

  var helperLengthArray = [0, 0, 0, 0, 0, 0];

  function length(arr1, arr2) {
    if (typeof arr1 === 'number' || arr1 instanceof Number) {
      arr2 = arr2 || 0;
      return Math.abs(arr1 - arr2);
    }
    if (!arr2) {
      arr2 = helperLengthArray;
    }
    var i;
    var len = Math.min(arr1.length, arr2.length);
    var addedLength = 0;
    for (i = 0; i < len; i += 1) {
      addedLength += Math.pow(arr2[i] - arr1[i], 2);
    }
    return Math.sqrt(addedLength);
  }

  function normalize(vec) {
    return div(vec, length(vec));
  }

  function rgbToHsl(val) {
    var r = val[0]; var g = val[1]; var b = val[2];
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h;
    var s;
    var l = (max + min) / 2;

    if (max === min) {
      h = 0; // achromatic
      s = 0; // achromatic
    } else {
      var d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
        default: break;
      }
      h /= 6;
    }

    return [h, s, l, val[3]];
  }

  function hue2rgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  }

  function hslToRgb(val) {
    var h = val[0];
    var s = val[1];
    var l = val[2];

    var r;
    var g;
    var b;

    if (s === 0) {
      r = l; // achromatic
      b = l; // achromatic
      g = l; // achromatic
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }

    return [r, g, b, val[3]];
  }

  function linear(t, tMin, tMax, value1, value2) {
    if (value1 === undefined || value2 === undefined) {
      value1 = tMin;
      value2 = tMax;
      tMin = 0;
      tMax = 1;
    }
    if (tMax < tMin) {
      var _tMin = tMax;
      tMax = tMin;
      tMin = _tMin;
    }
    if (t <= tMin) {
      return value1;
    } if (t >= tMax) {
      return value2;
    }
    var perc = tMax === tMin ? 0 : (t - tMin) / (tMax - tMin);
    if (!value1.length) {
      return value1 + (value2 - value1) * perc;
    }
    var i;
    var len = value1.length;
    var arr = createTypedArray('float32', len);
    for (i = 0; i < len; i += 1) {
      arr[i] = value1[i] + (value2[i] - value1[i]) * perc;
    }
    return arr;
  }
  function random(min, max) {
    if (max === undefined) {
      if (min === undefined) {
        min = 0;
        max = 1;
      } else {
        max = min;
        min = undefined;
      }
    }
    if (max.length) {
      var i;
      var len = max.length;
      if (!min) {
        min = createTypedArray('float32', len);
      }
      var arr = createTypedArray('float32', len);
      var rnd = BMMath.random();
      for (i = 0; i < len; i += 1) {
        arr[i] = min[i] + rnd * (max[i] - min[i]);
      }
      return arr;
    }
    if (min === undefined) {
      min = 0;
    }
    var rndm = BMMath.random();
    return min + rndm * (max - min);
  }

  function createPath(points, inTangents, outTangents, closed) {
    var i;
    var len = points.length;
    var path = shapePool.newElement();
    path.setPathData(!!closed, len);
    var arrPlaceholder = [0, 0];
    var inVertexPoint;
    var outVertexPoint;
    for (i = 0; i < len; i += 1) {
      inVertexPoint = (inTangents && inTangents[i]) ? inTangents[i] : arrPlaceholder;
      outVertexPoint = (outTangents && outTangents[i]) ? outTangents[i] : arrPlaceholder;
      path.setTripleAt(points[i][0], points[i][1], outVertexPoint[0] + points[i][0], outVertexPoint[1] + points[i][1], inVertexPoint[0] + points[i][0], inVertexPoint[1] + points[i][1], i, true);
    }
    return path;
  }

  function initiateExpression(elem, data, property) {
    // Bail out if we don't want expressions
    function noOp(_value) {
      return _value;
    }
    if (!elem.globalData.renderConfig.runExpressions) {
      return noOp;
    }

    var val = data.x;
    var needsVelocity = /velocity(?![\w\d])/.test(val);
    var _needsRandom = val.indexOf('random') !== -1;
    var elemType = elem.data.ty;
    var transform;
    var $bm_transform;
    var content;
    var effect;
    var thisProperty = property;
    thisProperty.valueAtTime = thisProperty.getValueAtTime;
    Object.defineProperty(thisProperty, 'value', {
      get: function () {
        return thisProperty.v;
      },
    });
    elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;
    elem.comp.displayStartTime = 0;
    var inPoint = elem.data.ip / elem.comp.globalData.frameRate;
    var outPoint = elem.data.op / elem.comp.globalData.frameRate;
    var width = elem.data.sw ? elem.data.sw : 0;
    var height = elem.data.sh ? elem.data.sh : 0;
    var name = elem.data.nm;
    var loopIn;
    var loop_in;
    var loopOut;
    var loop_out;
    var smooth;
    var toWorld;
    var fromWorld;
    var fromComp;
    var toComp;
    var fromCompToSurface;
    var position;
    var rotation;
    var anchorPoint;
    var scale;
    var thisLayer;
    var thisComp;
    var mask;
    var valueAtTime;
    var velocityAtTime;

    var scoped_bm_rt;
    // val = val.replace(/(\\?"|')((http)(s)?(:\/))?\/.*?(\\?"|')/g, "\"\""); // deter potential network calls
    var expression_function = eval('[function _expression_function(){' + val + ';scoped_bm_rt=$bm_rt}]')[0];  
    var numKeys = property.kf ? data.k.length : 0;

    var active = !this.data || this.data.hd !== true;

    var wiggle = function wiggle(freq, amp) {
      var iWiggle;
      var j;
      var lenWiggle = this.pv.length ? this.pv.length : 1;
      var addedAmps = createTypedArray('float32', lenWiggle);
      freq = 5;
      var iterations = Math.floor(time * freq);
      iWiggle = 0;
      j = 0;
      while (iWiggle < iterations) {
        // var rnd = BMMath.random();
        for (j = 0; j < lenWiggle; j += 1) {
          addedAmps[j] += -amp + amp * 2 * BMMath.random();
          // addedAmps[j] += -amp + amp*2*rnd;
        }
        iWiggle += 1;
      }
      // var rnd2 = BMMath.random();
      var periods = time * freq;
      var perc = periods - Math.floor(periods);
      var arr = createTypedArray('float32', lenWiggle);
      if (lenWiggle > 1) {
        for (j = 0; j < lenWiggle; j += 1) {
          arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp * 2 * BMMath.random()) * perc;
          // arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;
          // arr[i] = this.pv[i] + addedAmp + amp1*perc + amp2*(1-perc);
        }
        return arr;
      }
      return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;
    }.bind(this);

    if (thisProperty.loopIn) {
      loopIn = thisProperty.loopIn.bind(thisProperty);
      loop_in = loopIn;
    }

    if (thisProperty.loopOut) {
      loopOut = thisProperty.loopOut.bind(thisProperty);
      loop_out = loopOut;
    }

    if (thisProperty.smooth) {
      smooth = thisProperty.smooth.bind(thisProperty);
    }

    function loopInDuration(type, duration) {
      return loopIn(type, duration, true);
    }

    function loopOutDuration(type, duration) {
      return loopOut(type, duration, true);
    }

    if (this.getValueAtTime) {
      valueAtTime = this.getValueAtTime.bind(this);
    }

    if (this.getVelocityAtTime) {
      velocityAtTime = this.getVelocityAtTime.bind(this);
    }

    var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);

    function lookAt(elem1, elem2) {
      var fVec = [elem2[0] - elem1[0], elem2[1] - elem1[1], elem2[2] - elem1[2]];
      var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;
      var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;
      return [yaw, pitch, 0];
    }

    function easeOut(t, tMin, tMax, val1, val2) {
      return applyEase(easeOutBez, t, tMin, tMax, val1, val2);
    }

    function easeIn(t, tMin, tMax, val1, val2) {
      return applyEase(easeInBez, t, tMin, tMax, val1, val2);
    }

    function ease(t, tMin, tMax, val1, val2) {
      return applyEase(easeInOutBez, t, tMin, tMax, val1, val2);
    }

    function applyEase(fn, t, tMin, tMax, val1, val2) {
      if (val1 === undefined) {
        val1 = tMin;
        val2 = tMax;
      } else {
        t = (t - tMin) / (tMax - tMin);
      }
      if (t > 1) {
        t = 1;
      } else if (t < 0) {
        t = 0;
      }
      var mult = fn(t);
      if ($bm_isInstanceOfArray(val1)) {
        var iKey;
        var lenKey = val1.length;
        var arr = createTypedArray('float32', lenKey);
        for (iKey = 0; iKey < lenKey; iKey += 1) {
          arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];
        }
        return arr;
      }
      return (val2 - val1) * mult + val1;
    }

    function nearestKey(time) {
      var iKey;
      var lenKey = data.k.length;
      var index;
      var keyTime;
      if (!data.k.length || typeof (data.k[0]) === 'number') {
        index = 0;
        keyTime = 0;
      } else {
        index = -1;
        time *= elem.comp.globalData.frameRate;
        if (time < data.k[0].t) {
          index = 1;
          keyTime = data.k[0].t;
        } else {
          for (iKey = 0; iKey < lenKey - 1; iKey += 1) {
            if (time === data.k[iKey].t) {
              index = iKey + 1;
              keyTime = data.k[iKey].t;
              break;
            } else if (time > data.k[iKey].t && time < data.k[iKey + 1].t) {
              if (time - data.k[iKey].t > data.k[iKey + 1].t - time) {
                index = iKey + 2;
                keyTime = data.k[iKey + 1].t;
              } else {
                index = iKey + 1;
                keyTime = data.k[iKey].t;
              }
              break;
            }
          }
          if (index === -1) {
            index = iKey + 1;
            keyTime = data.k[iKey].t;
          }
        }
      }
      var obKey = {};
      obKey.index = index;
      obKey.time = keyTime / elem.comp.globalData.frameRate;
      return obKey;
    }

    function key(ind) {
      var obKey;
      var iKey;
      var lenKey;
      if (!data.k.length || typeof (data.k[0]) === 'number') {
        throw new Error('The property has no keyframe at index ' + ind);
      }
      ind -= 1;
      obKey = {
        time: data.k[ind].t / elem.comp.globalData.frameRate,
        value: [],
      };
      var arr = Object.prototype.hasOwnProperty.call(data.k[ind], 's') ? data.k[ind].s : data.k[ind - 1].e;

      lenKey = arr.length;
      for (iKey = 0; iKey < lenKey; iKey += 1) {
        obKey[iKey] = arr[iKey];
        obKey.value[iKey] = arr[iKey];
      }
      return obKey;
    }

    function framesToTime(fr, fps) {
      if (!fps) {
        fps = elem.comp.globalData.frameRate;
      }
      return fr / fps;
    }

    function timeToFrames(t, fps) {
      if (!t && t !== 0) {
        t = time;
      }
      if (!fps) {
        fps = elem.comp.globalData.frameRate;
      }
      return t * fps;
    }

    function seedRandom(seed) {
      BMMath.seedrandom(randSeed + seed);
    }

    function sourceRectAtTime() {
      return elem.sourceRectAtTime();
    }

    function substring(init, end) {
      if (typeof value === 'string') {
        if (end === undefined) {
          return value.substring(init);
        }
        return value.substring(init, end);
      }
      return '';
    }

    function substr(init, end) {
      if (typeof value === 'string') {
        if (end === undefined) {
          return value.substr(init);
        }
        return value.substr(init, end);
      }
      return '';
    }

    function posterizeTime(framesPerSecond) {
      time = framesPerSecond === 0 ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond;
      value = valueAtTime(time);
    }

    var time;
    var velocity;
    var value;
    var text;
    var textIndex;
    var textTotal;
    var selectorValue;
    var index = elem.data.ind;
    var hasParent = !!(elem.hierarchy && elem.hierarchy.length);
    var parent;
    var randSeed = Math.floor(Math.random() * 1000000);
    var globalData = elem.globalData;

    function executeExpression(_value) {
      // globalData.pushExpression();
      value = _value;
      if (this.frameExpressionId === elem.globalData.frameId && this.propType !== 'textSelector') {
        return value;
      }
      if (this.propType === 'textSelector') {
        textIndex = this.textIndex;
        textTotal = this.textTotal;
        selectorValue = this.selectorValue;
      }
      if (!thisLayer) {
        text = elem.layerInterface.text;
        thisLayer = elem.layerInterface;
        thisComp = elem.comp.compInterface;
        toWorld = thisLayer.toWorld.bind(thisLayer);
        fromWorld = thisLayer.fromWorld.bind(thisLayer);
        fromComp = thisLayer.fromComp.bind(thisLayer);
        toComp = thisLayer.toComp.bind(thisLayer);
        mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;
        fromCompToSurface = fromComp;
      }
      if (!transform) {
        transform = elem.layerInterface('ADBE Transform Group');
        $bm_transform = transform;
        if (transform) {
          anchorPoint = transform.anchorPoint;
          /* position = transform.position;
                    rotation = transform.rotation;
                    scale = transform.scale; */
        }
      }

      if (elemType === 4 && !content) {
        content = thisLayer('ADBE Root Vectors Group');
      }
      if (!effect) {
        effect = thisLayer(4);
      }
      hasParent = !!(elem.hierarchy && elem.hierarchy.length);
      if (hasParent && !parent) {
        parent = elem.hierarchy[0].layerInterface;
      }
      time = this.comp.renderedFrame / this.comp.globalData.frameRate;
      if (_needsRandom) {
        seedRandom(randSeed + time);
      }
      if (needsVelocity) {
        velocity = velocityAtTime(time);
      }
      expression_function();
      this.frameExpressionId = elem.globalData.frameId;

      // TODO: Check if it's possible to return on ShapeInterface the .v value
      // Changed this to a ternary operation because Rollup failed compiling it correctly
      scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE
        ? scoped_bm_rt.v
        : scoped_bm_rt;
      return scoped_bm_rt;
    }
    // Bundlers will see these as dead code and unless we reference them
    executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData];
    return executeExpression;
  }

  ob.initiateExpression = initiateExpression;
  ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal];
  ob.resetFrame = resetFrame;
  return ob;
}());

const Expressions = (function () {
  var ob = {};
  ob.initExpressions = initExpressions;
  ob.resetFrame = ExpressionManager.resetFrame;

  function initExpressions(animation) {
    var stackCount = 0;
    var registers = [];

    function pushExpression() {
      stackCount += 1;
    }

    function popExpression() {
      stackCount -= 1;
      if (stackCount === 0) {
        releaseInstances();
      }
    }

    function registerExpressionProperty(expression) {
      if (registers.indexOf(expression) === -1) {
        registers.push(expression);
      }
    }

    function releaseInstances() {
      var i;
      var len = registers.length;
      for (i = 0; i < len; i += 1) {
        registers[i].release();
      }
      registers.length = 0;
    }

    animation.renderer.compInterface = CompExpressionInterface(animation.renderer);
    animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);
    animation.renderer.globalData.pushExpression = pushExpression;
    animation.renderer.globalData.popExpression = popExpression;
    animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;
  }
  return ob;
}());

const MaskManagerInterface = (function () {
  function MaskInterface(mask, data) {
    this._mask = mask;
    this._data = data;
  }
  Object.defineProperty(MaskInterface.prototype, 'maskPath', {
    get: function () {
      if (this._mask.prop.k) {
        this._mask.prop.getValue();
      }
      return this._mask.prop;
    },
  });
  Object.defineProperty(MaskInterface.prototype, 'maskOpacity', {
    get: function () {
      if (this._mask.op.k) {
        this._mask.op.getValue();
      }
      return this._mask.op.v * 100;
    },
  });

  var MaskManager = function (maskManager) {
    var _masksInterfaces = createSizedArray(maskManager.viewData.length);
    var i;
    var len = maskManager.viewData.length;
    for (i = 0; i < len; i += 1) {
      _masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);
    }

    var maskFunction = function (name) {
      i = 0;
      while (i < len) {
        if (maskManager.masksProperties[i].nm === name) {
          return _masksInterfaces[i];
        }
        i += 1;
      }
      return null;
    };
    return maskFunction;
  };
  return MaskManager;
}());

const ExpressionPropertyInterface = (function () {
  var defaultUnidimensionalValue = { pv: 0, v: 0, mult: 1 };
  var defaultMultidimensionalValue = { pv: [0, 0, 0], v: [0, 0, 0], mult: 1 };

  function completeProperty(expressionValue, property, type) {
    Object.defineProperty(expressionValue, 'velocity', {
      get: function () {
        return property.getVelocityAtTime(property.comp.currentFrame);
      },
    });
    expressionValue.numKeys = property.keyframes ? property.keyframes.length : 0;
    expressionValue.key = function (pos) {
      if (!expressionValue.numKeys) {
        return 0;
      }
      var value = '';
      if ('s' in property.keyframes[pos - 1]) {
        value = property.keyframes[pos - 1].s;
      } else if ('e' in property.keyframes[pos - 2]) {
        value = property.keyframes[pos - 2].e;
      } else {
        value = property.keyframes[pos - 2].s;
      }
      var valueProp = type === 'unidimensional' ? new Number(value) : Object.assign({}, value);  
      valueProp.time = property.keyframes[pos - 1].t / property.elem.comp.globalData.frameRate;
      valueProp.value = type === 'unidimensional' ? value[0] : value;
      return valueProp;
    };
    expressionValue.valueAtTime = property.getValueAtTime;
    expressionValue.speedAtTime = property.getSpeedAtTime;
    expressionValue.velocityAtTime = property.getVelocityAtTime;
    expressionValue.propertyGroup = property.propertyGroup;
  }

  function UnidimensionalPropertyInterface(property) {
    if (!property || !('pv' in property)) {
      property = defaultUnidimensionalValue;
    }
    var mult = 1 / property.mult;
    var val = property.pv * mult;
    var expressionValue = new Number(val);  
    expressionValue.value = val;
    completeProperty(expressionValue, property, 'unidimensional');

    return function () {
      if (property.k) {
        property.getValue();
      }
      val = property.v * mult;
      if (expressionValue.value !== val) {
        expressionValue = new Number(val);  
        expressionValue.value = val;
        completeProperty(expressionValue, property, 'unidimensional');
      }
      return expressionValue;
    };
  }

  function MultidimensionalPropertyInterface(property) {
    if (!property || !('pv' in property)) {
      property = defaultMultidimensionalValue;
    }
    var mult = 1 / property.mult;
    var len = (property.data && property.data.l) || property.pv.length;
    var expressionValue = createTypedArray('float32', len);
    var arrValue = createTypedArray('float32', len);
    expressionValue.value = arrValue;
    completeProperty(expressionValue, property, 'multidimensional');

    return function () {
      if (property.k) {
        property.getValue();
      }
      for (var i = 0; i < len; i += 1) {
        arrValue[i] = property.v[i] * mult;
        expressionValue[i] = arrValue[i];
      }
      return expressionValue;
    };
  }

  // TODO: try to avoid using this getter
  function defaultGetter() {
    return defaultUnidimensionalValue;
  }

  return function (property) {
    if (!property) {
      return defaultGetter;
    } if (property.propType === 'unidimensional') {
      return UnidimensionalPropertyInterface(property);
    }
    return MultidimensionalPropertyInterface(property);
  };
}());

const TransformExpressionInterface = (function () {
  return function (transform) {
    function _thisFunction(name) {
      switch (name) {
        case 'scale':
        case 'Scale':
        case 'ADBE Scale':
        case 6:
          return _thisFunction.scale;
        case 'rotation':
        case 'Rotation':
        case 'ADBE Rotation':
        case 'ADBE Rotate Z':
        case 10:
          return _thisFunction.rotation;
        case 'ADBE Rotate X':
          return _thisFunction.xRotation;
        case 'ADBE Rotate Y':
          return _thisFunction.yRotation;
        case 'position':
        case 'Position':
        case 'ADBE Position':
        case 2:
          return _thisFunction.position;
        case 'ADBE Position_0':
          return _thisFunction.xPosition;
        case 'ADBE Position_1':
          return _thisFunction.yPosition;
        case 'ADBE Position_2':
          return _thisFunction.zPosition;
        case 'anchorPoint':
        case 'AnchorPoint':
        case 'Anchor Point':
        case 'ADBE AnchorPoint':
        case 1:
          return _thisFunction.anchorPoint;
        case 'opacity':
        case 'Opacity':
        case 11:
          return _thisFunction.opacity;
        default:
          return null;
      }
    }
    Object.defineProperty(_thisFunction, 'rotation', {
      get: ExpressionPropertyInterface(transform.r || transform.rz),
    });

    Object.defineProperty(_thisFunction, 'zRotation', {
      get: ExpressionPropertyInterface(transform.rz || transform.r),
    });

    Object.defineProperty(_thisFunction, 'xRotation', {
      get: ExpressionPropertyInterface(transform.rx),
    });

    Object.defineProperty(_thisFunction, 'yRotation', {
      get: ExpressionPropertyInterface(transform.ry),
    });
    Object.defineProperty(_thisFunction, 'scale', {
      get: ExpressionPropertyInterface(transform.s),
    });
    var _px;
    var _py;
    var _pz;
    var _transformFactory;
    if (transform.p) {
      _transformFactory = ExpressionPropertyInterface(transform.p);
    } else {
      _px = ExpressionPropertyInterface(transform.px);
      _py = ExpressionPropertyInterface(transform.py);
      if (transform.pz) {
        _pz = ExpressionPropertyInterface(transform.pz);
      }
    }
    Object.defineProperty(_thisFunction, 'position', {
      get: function () {
        if (transform.p) {
          return _transformFactory();
        }
        return [
          _px(),
          _py(),
          _pz ? _pz() : 0];
      },
    });

    Object.defineProperty(_thisFunction, 'xPosition', {
      get: ExpressionPropertyInterface(transform.px),
    });

    Object.defineProperty(_thisFunction, 'yPosition', {
      get: ExpressionPropertyInterface(transform.py),
    });

    Object.defineProperty(_thisFunction, 'zPosition', {
      get: ExpressionPropertyInterface(transform.pz),
    });

    Object.defineProperty(_thisFunction, 'anchorPoint', {
      get: ExpressionPropertyInterface(transform.a),
    });

    Object.defineProperty(_thisFunction, 'opacity', {
      get: ExpressionPropertyInterface(transform.o),
    });

    Object.defineProperty(_thisFunction, 'skew', {
      get: ExpressionPropertyInterface(transform.sk),
    });

    Object.defineProperty(_thisFunction, 'skewAxis', {
      get: ExpressionPropertyInterface(transform.sa),
    });

    Object.defineProperty(_thisFunction, 'orientation', {
      get: ExpressionPropertyInterface(transform.or),
    });

    return _thisFunction;
  };
}());

const LayerExpressionInterface = (function () {
  function getMatrix(time) {
    var toWorldMat = new Matrix();
    if (time !== undefined) {
      var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time);
      propMatrix.clone(toWorldMat);
    } else {
      var transformMat = this._elem.finalTransform.mProp;
      transformMat.applyToMatrix(toWorldMat);
    }
    return toWorldMat;
  }

  function toWorldVec(arr, time) {
    var toWorldMat = this.getMatrix(time);
    toWorldMat.props[12] = 0;
    toWorldMat.props[13] = 0;
    toWorldMat.props[14] = 0;
    return this.applyPoint(toWorldMat, arr);
  }

  function toWorld(arr, time) {
    var toWorldMat = this.getMatrix(time);
    return this.applyPoint(toWorldMat, arr);
  }

  function fromWorldVec(arr, time) {
    var toWorldMat = this.getMatrix(time);
    toWorldMat.props[12] = 0;
    toWorldMat.props[13] = 0;
    toWorldMat.props[14] = 0;
    return this.invertPoint(toWorldMat, arr);
  }

  function fromWorld(arr, time) {
    var toWorldMat = this.getMatrix(time);
    return this.invertPoint(toWorldMat, arr);
  }

  function applyPoint(matrix, arr) {
    if (this._elem.hierarchy && this._elem.hierarchy.length) {
      var i;
      var len = this._elem.hierarchy.length;
      for (i = 0; i < len; i += 1) {
        this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
      }
    }
    return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0);
  }

  function invertPoint(matrix, arr) {
    if (this._elem.hierarchy && this._elem.hierarchy.length) {
      var i;
      var len = this._elem.hierarchy.length;
      for (i = 0; i < len; i += 1) {
        this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
      }
    }
    return matrix.inversePoint(arr);
  }

  function fromComp(arr) {
    var toWorldMat = new Matrix();
    toWorldMat.reset();
    this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);
    if (this._elem.hierarchy && this._elem.hierarchy.length) {
      var i;
      var len = this._elem.hierarchy.length;
      for (i = 0; i < len; i += 1) {
        this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
      }
      return toWorldMat.inversePoint(arr);
    }
    return toWorldMat.inversePoint(arr);
  }

  function sampleImage() {
    return [1, 1, 1, 1];
  }

  return function (elem) {
    var transformInterface;

    function _registerMaskInterface(maskManager) {
      _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem);
    }
    function _registerEffectsInterface(effects) {
      _thisLayerFunction.effect = effects;
    }

    function _thisLayerFunction(name) {
      switch (name) {
        case 'ADBE Root Vectors Group':
        case 'Contents':
        case 2:
          return _thisLayerFunction.shapeInterface;
        case 1:
        case 6:
        case 'Transform':
        case 'transform':
        case 'ADBE Transform Group':
          return transformInterface;
        case 4:
        case 'ADBE Effect Parade':
        case 'effects':
        case 'Effects':
          return _thisLayerFunction.effect;
        case 'ADBE Text Properties':
          return _thisLayerFunction.textInterface;
        default:
          return null;
      }
    }
    _thisLayerFunction.getMatrix = getMatrix;
    _thisLayerFunction.invertPoint = invertPoint;
    _thisLayerFunction.applyPoint = applyPoint;
    _thisLayerFunction.toWorld = toWorld;
    _thisLayerFunction.toWorldVec = toWorldVec;
    _thisLayerFunction.fromWorld = fromWorld;
    _thisLayerFunction.fromWorldVec = fromWorldVec;
    _thisLayerFunction.toComp = toWorld;
    _thisLayerFunction.fromComp = fromComp;
    _thisLayerFunction.sampleImage = sampleImage;
    _thisLayerFunction.sourceRectAtTime = elem.sourceRectAtTime.bind(elem);
    _thisLayerFunction._elem = elem;
    transformInterface = TransformExpressionInterface(elem.finalTransform.mProp);
    var anchorPointDescriptor = getDescriptor(transformInterface, 'anchorPoint');
    Object.defineProperties(_thisLayerFunction, {
      hasParent: {
        get: function () {
          return elem.hierarchy.length;
        },
      },
      parent: {
        get: function () {
          return elem.hierarchy[0].layerInterface;
        },
      },
      rotation: getDescriptor(transformInterface, 'rotation'),
      scale: getDescriptor(transformInterface, 'scale'),
      position: getDescriptor(transformInterface, 'position'),
      opacity: getDescriptor(transformInterface, 'opacity'),
      anchorPoint: anchorPointDescriptor,
      anchor_point: anchorPointDescriptor,
      transform: {
        get: function () {
          return transformInterface;
        },
      },
      active: {
        get: function () {
          return elem.isInRange;
        },
      },
    });

    _thisLayerFunction.startTime = elem.data.st;
    _thisLayerFunction.index = elem.data.ind;
    _thisLayerFunction.source = elem.data.refId;
    _thisLayerFunction.height = elem.data.ty === 0 ? elem.data.h : 100;
    _thisLayerFunction.width = elem.data.ty === 0 ? elem.data.w : 100;
    _thisLayerFunction.inPoint = elem.data.ip / elem.comp.globalData.frameRate;
    _thisLayerFunction.outPoint = elem.data.op / elem.comp.globalData.frameRate;
    _thisLayerFunction._name = elem.data.nm;

    _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
    _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;
    return _thisLayerFunction;
  };
}());

const propertyGroupFactory = (function () {
  return function (interfaceFunction, parentPropertyGroup) {
    return function (val) {
      val = val === undefined ? 1 : val;
      if (val <= 0) {
        return interfaceFunction;
      }
      return parentPropertyGroup(val - 1);
    };
  };
}());

const PropertyInterface = (function () {
  return function (propertyName, propertyGroup) {
    var interfaceFunction = {
      _name: propertyName,
    };

    function _propertyGroup(val) {
      val = val === undefined ? 1 : val;
      if (val <= 0) {
        return interfaceFunction;
      }
      return propertyGroup(val - 1);
    }

    return _propertyGroup;
  };
}());

const EffectsExpressionInterface = (function () {
  var ob = {
    createEffectsInterface: createEffectsInterface,
  };

  function createEffectsInterface(elem, propertyGroup) {
    if (elem.effectsManager) {
      var effectElements = [];
      var effectsData = elem.data.ef;
      var i;
      var len = elem.effectsManager.effectElements.length;
      for (i = 0; i < len; i += 1) {
        effectElements.push(createGroupInterface(effectsData[i], elem.effectsManager.effectElements[i], propertyGroup, elem));
      }

      var effects = elem.data.ef || [];
      var groupInterface = function (name) {
        i = 0;
        len = effects.length;
        while (i < len) {
          if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {
            return effectElements[i];
          }
          i += 1;
        }
        return null;
      };
      Object.defineProperty(groupInterface, 'numProperties', {
        get: function () {
          return effects.length;
        },
      });
      return groupInterface;
    }
    return null;
  }

  function createGroupInterface(data, elements, propertyGroup, elem) {
    function groupInterface(name) {
      var effects = data.ef;
      var i = 0;
      var len = effects.length;
      while (i < len) {
        if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {
          if (effects[i].ty === 5) {
            return effectElements[i];
          }
          return effectElements[i]();
        }
        i += 1;
      }
      throw new Error();
    }
    var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);

    var effectElements = [];
    var i;
    var len = data.ef.length;
    for (i = 0; i < len; i += 1) {
      if (data.ef[i].ty === 5) {
        effectElements.push(createGroupInterface(data.ef[i], elements.effectElements[i], elements.effectElements[i].propertyGroup, elem));
      } else {
        effectElements.push(createValueInterface(elements.effectElements[i], data.ef[i].ty, elem, _propertyGroup));
      }
    }

    if (data.mn === 'ADBE Color Control') {
      Object.defineProperty(groupInterface, 'color', {
        get: function () {
          return effectElements[0]();
        },
      });
    }
    Object.defineProperties(groupInterface, {
      numProperties: {
        get: function () {
          return data.np;
        },
      },
      _name: { value: data.nm },
      propertyGroup: { value: _propertyGroup },
    });
    groupInterface.enabled = data.en !== 0;
    groupInterface.active = groupInterface.enabled;
    return groupInterface;
  }

  function createValueInterface(element, type, elem, propertyGroup) {
    var expressionProperty = ExpressionPropertyInterface(element.p);
    function interfaceFunction() {
      if (type === 10) {
        return elem.comp.compInterface(element.p.v);
      }
      return expressionProperty();
    }

    if (element.p.setGroupProperty) {
      element.p.setGroupProperty(PropertyInterface('', propertyGroup));
    }

    return interfaceFunction;
  }

  return ob;
}());

const ShapePathInterface = (

  function () {
    return function pathInterfaceFactory(shape, view, propertyGroup) {
      var prop = view.sh;

      function interfaceFunction(val) {
        if (val === 'Shape' || val === 'shape' || val === 'Path' || val === 'path' || val === 'ADBE Vector Shape' || val === 2) {
          return interfaceFunction.path;
        }
        return null;
      }

      var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
      prop.setGroupProperty(PropertyInterface('Path', _propertyGroup));
      Object.defineProperties(interfaceFunction, {
        path: {
          get: function () {
            if (prop.k) {
              prop.getValue();
            }
            return prop;
          },
        },
        shape: {
          get: function () {
            if (prop.k) {
              prop.getValue();
            }
            return prop;
          },
        },
        _name: { value: shape.nm },
        ix: { value: shape.ix },
        propertyIndex: { value: shape.ix },
        mn: { value: shape.mn },
        propertyGroup: { value: propertyGroup },
      });
      return interfaceFunction;
    };
  }()
);

const ShapeExpressionInterface = (function () {
  function iterateElements(shapes, view, propertyGroup) {
    var arr = [];
    var i;
    var len = shapes ? shapes.length : 0;
    for (i = 0; i < len; i += 1) {
      if (shapes[i].ty === 'gr') {
        arr.push(groupInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'fl') {
        arr.push(fillInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'st') {
        arr.push(strokeInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'tm') {
        arr.push(trimInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'tr') {
        // arr.push(transformInterfaceFactory(shapes[i],view[i],propertyGroup));
      } else if (shapes[i].ty === 'el') {
        arr.push(ellipseInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'sr') {
        arr.push(starInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'sh') {
        arr.push(ShapePathInterface(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'rc') {
        arr.push(rectInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'rd') {
        arr.push(roundedInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'rp') {
        arr.push(repeaterInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else if (shapes[i].ty === 'gf') {
        arr.push(gradientFillInterfaceFactory(shapes[i], view[i], propertyGroup));
      } else {
        arr.push(defaultInterfaceFactory(shapes[i], view[i], propertyGroup));
      }
    }
    return arr;
  }

  function contentsInterfaceFactory(shape, view, propertyGroup) {
    var interfaces;
    var interfaceFunction = function _interfaceFunction(value) {
      var i = 0;
      var len = interfaces.length;
      while (i < len) {
        if (interfaces[i]._name === value || interfaces[i].mn === value || interfaces[i].propertyIndex === value || interfaces[i].ix === value || interfaces[i].ind === value) {
          return interfaces[i];
        }
        i += 1;
      }
      if (typeof value === 'number') {
        return interfaces[value - 1];
      }
      return null;
    };

    interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);
    interfaceFunction.numProperties = interfaces.length;
    var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
    interfaceFunction.transform = transformInterface;
    interfaceFunction.propertyIndex = shape.cix;
    interfaceFunction._name = shape.nm;

    return interfaceFunction;
  }

  function groupInterfaceFactory(shape, view, propertyGroup) {
    var interfaceFunction = function _interfaceFunction(value) {
      switch (value) {
        case 'ADBE Vectors Group':
        case 'Contents':
        case 2:
          return interfaceFunction.content;
          // Not necessary for now. Keeping them here in case a new case appears
          // case 'ADBE Vector Transform Group':
          // case 3:
        default:
          return interfaceFunction.transform;
      }
    };
    interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    var content = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);
    var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
    interfaceFunction.content = content;
    interfaceFunction.transform = transformInterface;
    Object.defineProperty(interfaceFunction, '_name', {
      get: function () {
        return shape.nm;
      },
    });
    // interfaceFunction.content = interfaceFunction;
    interfaceFunction.numProperties = shape.np;
    interfaceFunction.propertyIndex = shape.ix;
    interfaceFunction.nm = shape.nm;
    interfaceFunction.mn = shape.mn;
    return interfaceFunction;
  }

  function fillInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(val) {
      if (val === 'Color' || val === 'color') {
        return interfaceFunction.color;
      } if (val === 'Opacity' || val === 'opacity') {
        return interfaceFunction.opacity;
      }
      return null;
    }
    Object.defineProperties(interfaceFunction, {
      color: {
        get: ExpressionPropertyInterface(view.c),
      },
      opacity: {
        get: ExpressionPropertyInterface(view.o),
      },
      _name: { value: shape.nm },
      mn: { value: shape.mn },
    });

    view.c.setGroupProperty(PropertyInterface('Color', propertyGroup));
    view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));
    return interfaceFunction;
  }

  function gradientFillInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(val) {
      if (val === 'Start Point' || val === 'start point') {
        return interfaceFunction.startPoint;
      }
      if (val === 'End Point' || val === 'end point') {
        return interfaceFunction.endPoint;
      }
      if (val === 'Opacity' || val === 'opacity') {
        return interfaceFunction.opacity;
      }
      return null;
    }
    Object.defineProperties(interfaceFunction, {
      startPoint: {
        get: ExpressionPropertyInterface(view.s),
      },
      endPoint: {
        get: ExpressionPropertyInterface(view.e),
      },
      opacity: {
        get: ExpressionPropertyInterface(view.o),
      },
      type: {
        get: function () {
          return 'a';
        },
      },
      _name: { value: shape.nm },
      mn: { value: shape.mn },
    });

    view.s.setGroupProperty(PropertyInterface('Start Point', propertyGroup));
    view.e.setGroupProperty(PropertyInterface('End Point', propertyGroup));
    view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));
    return interfaceFunction;
  }
  function defaultInterfaceFactory() {
    function interfaceFunction() {
      return null;
    }
    return interfaceFunction;
  }

  function strokeInterfaceFactory(shape, view, propertyGroup) {
    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);
    function addPropertyToDashOb(i) {
      Object.defineProperty(dashOb, shape.d[i].nm, {
        get: ExpressionPropertyInterface(view.d.dataProps[i].p),
      });
    }
    var i;
    var len = shape.d ? shape.d.length : 0;
    var dashOb = {};
    for (i = 0; i < len; i += 1) {
      addPropertyToDashOb(i);
      view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);
    }

    function interfaceFunction(val) {
      if (val === 'Color' || val === 'color') {
        return interfaceFunction.color;
      } if (val === 'Opacity' || val === 'opacity') {
        return interfaceFunction.opacity;
      } if (val === 'Stroke Width' || val === 'stroke width') {
        return interfaceFunction.strokeWidth;
      }
      return null;
    }
    Object.defineProperties(interfaceFunction, {
      color: {
        get: ExpressionPropertyInterface(view.c),
      },
      opacity: {
        get: ExpressionPropertyInterface(view.o),
      },
      strokeWidth: {
        get: ExpressionPropertyInterface(view.w),
      },
      dash: {
        get: function () {
          return dashOb;
        },
      },
      _name: { value: shape.nm },
      mn: { value: shape.mn },
    });

    view.c.setGroupProperty(PropertyInterface('Color', _propertyGroup));
    view.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
    view.w.setGroupProperty(PropertyInterface('Stroke Width', _propertyGroup));
    return interfaceFunction;
  }

  function trimInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(val) {
      if (val === shape.e.ix || val === 'End' || val === 'end') {
        return interfaceFunction.end;
      }
      if (val === shape.s.ix) {
        return interfaceFunction.start;
      }
      if (val === shape.o.ix) {
        return interfaceFunction.offset;
      }
      return null;
    }

    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    interfaceFunction.propertyIndex = shape.ix;

    view.s.setGroupProperty(PropertyInterface('Start', _propertyGroup));
    view.e.setGroupProperty(PropertyInterface('End', _propertyGroup));
    view.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));
    interfaceFunction.propertyIndex = shape.ix;
    interfaceFunction.propertyGroup = propertyGroup;

    Object.defineProperties(interfaceFunction, {
      start: {
        get: ExpressionPropertyInterface(view.s),
      },
      end: {
        get: ExpressionPropertyInterface(view.e),
      },
      offset: {
        get: ExpressionPropertyInterface(view.o),
      },
      _name: { value: shape.nm },
    });
    interfaceFunction.mn = shape.mn;
    return interfaceFunction;
  }

  function transformInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(value) {
      if (shape.a.ix === value || value === 'Anchor Point') {
        return interfaceFunction.anchorPoint;
      }
      if (shape.o.ix === value || value === 'Opacity') {
        return interfaceFunction.opacity;
      }
      if (shape.p.ix === value || value === 'Position') {
        return interfaceFunction.position;
      }
      if (shape.r.ix === value || value === 'Rotation' || value === 'ADBE Vector Rotation') {
        return interfaceFunction.rotation;
      }
      if (shape.s.ix === value || value === 'Scale') {
        return interfaceFunction.scale;
      }
      if ((shape.sk && shape.sk.ix === value) || value === 'Skew') {
        return interfaceFunction.skew;
      }
      if ((shape.sa && shape.sa.ix === value) || value === 'Skew Axis') {
        return interfaceFunction.skewAxis;
      }
      return null;
    }
    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    view.transform.mProps.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
    view.transform.mProps.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
    view.transform.mProps.a.setGroupProperty(PropertyInterface('Anchor Point', _propertyGroup));
    view.transform.mProps.s.setGroupProperty(PropertyInterface('Scale', _propertyGroup));
    view.transform.mProps.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
    if (view.transform.mProps.sk) {
      view.transform.mProps.sk.setGroupProperty(PropertyInterface('Skew', _propertyGroup));
      view.transform.mProps.sa.setGroupProperty(PropertyInterface('Skew Angle', _propertyGroup));
    }
    view.transform.op.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
    Object.defineProperties(interfaceFunction, {
      opacity: {
        get: ExpressionPropertyInterface(view.transform.mProps.o),
      },
      position: {
        get: ExpressionPropertyInterface(view.transform.mProps.p),
      },
      anchorPoint: {
        get: ExpressionPropertyInterface(view.transform.mProps.a),
      },
      scale: {
        get: ExpressionPropertyInterface(view.transform.mProps.s),
      },
      rotation: {
        get: ExpressionPropertyInterface(view.transform.mProps.r),
      },
      skew: {
        get: ExpressionPropertyInterface(view.transform.mProps.sk),
      },
      skewAxis: {
        get: ExpressionPropertyInterface(view.transform.mProps.sa),
      },
      _name: { value: shape.nm },
    });
    interfaceFunction.ty = 'tr';
    interfaceFunction.mn = shape.mn;
    interfaceFunction.propertyGroup = propertyGroup;
    return interfaceFunction;
  }

  function ellipseInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(value) {
      if (shape.p.ix === value) {
        return interfaceFunction.position;
      }
      if (shape.s.ix === value) {
        return interfaceFunction.size;
      }
      return null;
    }
    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    interfaceFunction.propertyIndex = shape.ix;
    var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
    prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));
    prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));

    Object.defineProperties(interfaceFunction, {
      size: {
        get: ExpressionPropertyInterface(prop.s),
      },
      position: {
        get: ExpressionPropertyInterface(prop.p),
      },
      _name: { value: shape.nm },
    });
    interfaceFunction.mn = shape.mn;
    return interfaceFunction;
  }

  function starInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(value) {
      if (shape.p.ix === value) {
        return interfaceFunction.position;
      }
      if (shape.r.ix === value) {
        return interfaceFunction.rotation;
      }
      if (shape.pt.ix === value) {
        return interfaceFunction.points;
      }
      if (shape.or.ix === value || value === 'ADBE Vector Star Outer Radius') {
        return interfaceFunction.outerRadius;
      }
      if (shape.os.ix === value) {
        return interfaceFunction.outerRoundness;
      }
      if (shape.ir && (shape.ir.ix === value || value === 'ADBE Vector Star Inner Radius')) {
        return interfaceFunction.innerRadius;
      }
      if (shape.is && shape.is.ix === value) {
        return interfaceFunction.innerRoundness;
      }
      return null;
    }

    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
    interfaceFunction.propertyIndex = shape.ix;
    prop.or.setGroupProperty(PropertyInterface('Outer Radius', _propertyGroup));
    prop.os.setGroupProperty(PropertyInterface('Outer Roundness', _propertyGroup));
    prop.pt.setGroupProperty(PropertyInterface('Points', _propertyGroup));
    prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
    prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
    if (shape.ir) {
      prop.ir.setGroupProperty(PropertyInterface('Inner Radius', _propertyGroup));
      prop.is.setGroupProperty(PropertyInterface('Inner Roundness', _propertyGroup));
    }

    Object.defineProperties(interfaceFunction, {
      position: {
        get: ExpressionPropertyInterface(prop.p),
      },
      rotation: {
        get: ExpressionPropertyInterface(prop.r),
      },
      points: {
        get: ExpressionPropertyInterface(prop.pt),
      },
      outerRadius: {
        get: ExpressionPropertyInterface(prop.or),
      },
      outerRoundness: {
        get: ExpressionPropertyInterface(prop.os),
      },
      innerRadius: {
        get: ExpressionPropertyInterface(prop.ir),
      },
      innerRoundness: {
        get: ExpressionPropertyInterface(prop.is),
      },
      _name: { value: shape.nm },
    });
    interfaceFunction.mn = shape.mn;
    return interfaceFunction;
  }

  function rectInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(value) {
      if (shape.p.ix === value) {
        return interfaceFunction.position;
      }
      if (shape.r.ix === value) {
        return interfaceFunction.roundness;
      }
      if (shape.s.ix === value || value === 'Size' || value === 'ADBE Vector Rect Size') {
        return interfaceFunction.size;
      }
      return null;
    }
    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);

    var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
    interfaceFunction.propertyIndex = shape.ix;
    prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
    prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));
    prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));

    Object.defineProperties(interfaceFunction, {
      position: {
        get: ExpressionPropertyInterface(prop.p),
      },
      roundness: {
        get: ExpressionPropertyInterface(prop.r),
      },
      size: {
        get: ExpressionPropertyInterface(prop.s),
      },
      _name: { value: shape.nm },
    });
    interfaceFunction.mn = shape.mn;
    return interfaceFunction;
  }

  function roundedInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(value) {
      if (shape.r.ix === value || value === 'Round Corners 1') {
        return interfaceFunction.radius;
      }
      return null;
    }

    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    var prop = view;
    interfaceFunction.propertyIndex = shape.ix;
    prop.rd.setGroupProperty(PropertyInterface('Radius', _propertyGroup));

    Object.defineProperties(interfaceFunction, {
      radius: {
        get: ExpressionPropertyInterface(prop.rd),
      },
      _name: { value: shape.nm },
    });
    interfaceFunction.mn = shape.mn;
    return interfaceFunction;
  }

  function repeaterInterfaceFactory(shape, view, propertyGroup) {
    function interfaceFunction(value) {
      if (shape.c.ix === value || value === 'Copies') {
        return interfaceFunction.copies;
      } if (shape.o.ix === value || value === 'Offset') {
        return interfaceFunction.offset;
      }
      return null;
    }

    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    var prop = view;
    interfaceFunction.propertyIndex = shape.ix;
    prop.c.setGroupProperty(PropertyInterface('Copies', _propertyGroup));
    prop.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));
    Object.defineProperties(interfaceFunction, {
      copies: {
        get: ExpressionPropertyInterface(prop.c),
      },
      offset: {
        get: ExpressionPropertyInterface(prop.o),
      },
      _name: { value: shape.nm },
    });
    interfaceFunction.mn = shape.mn;
    return interfaceFunction;
  }

  return function (shapes, view, propertyGroup) {
    var interfaces;
    function _interfaceFunction(value) {
      if (typeof value === 'number') {
        value = value === undefined ? 1 : value;
        if (value === 0) {
          return propertyGroup;
        }
        return interfaces[value - 1];
      }
      var i = 0;
      var len = interfaces.length;
      while (i < len) {
        if (interfaces[i]._name === value) {
          return interfaces[i];
        }
        i += 1;
      }
      return null;
    }
    function parentGroupWrapper() {
      return propertyGroup;
    }
    _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper);
    interfaces = iterateElements(shapes, view, _interfaceFunction.propertyGroup);
    _interfaceFunction.numProperties = interfaces.length;
    _interfaceFunction._name = 'Contents';
    return _interfaceFunction;
  };
}());

const TextExpressionInterface = (function () {
  return function (elem) {
    var _sourceText;
    function _thisLayerFunction(name) {
      switch (name) {
        case 'ADBE Text Document':
          return _thisLayerFunction.sourceText;
        default:
          return null;
      }
    }
    Object.defineProperty(_thisLayerFunction, 'sourceText', {
      get: function () {
        elem.textProperty.getValue();
        var stringValue = elem.textProperty.currentData.t;
        if (!_sourceText || stringValue !== _sourceText.value) {
          _sourceText = new String(stringValue);  
          // If stringValue is an empty string, eval returns undefined, so it has to be returned as a String primitive
          _sourceText.value = stringValue || new String(stringValue);  
          Object.defineProperty(_sourceText, 'style', {
            get: function () {
              return {
                fillColor: elem.textProperty.currentData.fc,
              };
            },
          });
        }
        return _sourceText;
      },
    });
    return _thisLayerFunction;
  };
}());

const FootageInterface = (function () {
  var outlineInterfaceFactory = (function (elem) {
    var currentPropertyName = '';
    var currentProperty = elem.getFootageData();
    function init() {
      currentPropertyName = '';
      currentProperty = elem.getFootageData();
      return searchProperty;
    }
    function searchProperty(value) {
      if (currentProperty[value]) {
        currentPropertyName = value;
        currentProperty = currentProperty[value];
        if (typeof currentProperty === 'object') {
          return searchProperty;
        }
        return currentProperty;
      }
      var propertyNameIndex = value.indexOf(currentPropertyName);
      if (propertyNameIndex !== -1) {
        var index = parseInt(value.substr(propertyNameIndex + currentPropertyName.length), 10);
        currentProperty = currentProperty[index];
        if (typeof currentProperty === 'object') {
          return searchProperty;
        }
        return currentProperty;
      }
      return '';
    }
    return init;
  });

  var dataInterfaceFactory = function (elem) {
    function interfaceFunction(value) {
      if (value === 'Outline') {
        return interfaceFunction.outlineInterface();
      }
      return null;
    }

    interfaceFunction._name = 'Outline';
    interfaceFunction.outlineInterface = outlineInterfaceFactory(elem);
    return interfaceFunction;
  };

  return function (elem) {
    function _interfaceFunction(value) {
      if (value === 'Data') {
        return _interfaceFunction.dataInterface;
      }
      return null;
    }

    _interfaceFunction._name = 'Data';
    _interfaceFunction.dataInterface = dataInterfaceFactory(elem);
    return _interfaceFunction;
  };
}());

var interfaces = {
  layer: LayerExpressionInterface,
  effects: EffectsExpressionInterface,
  comp: CompExpressionInterface,
  shape: ShapeExpressionInterface,
  text: TextExpressionInterface,
  footage: FootageInterface,
};

function getInterface(type) {
  return interfaces[type] || null;
}

const expressionHelpers = (function () {
  function searchExpressions(elem, data, prop) {
    if (data.x) {
      prop.k = true;
      prop.x = true;
      prop.initiateExpression = ExpressionManager.initiateExpression;
      prop.effectsSequence.push(prop.initiateExpression(elem, data, prop).bind(prop));
    }
  }

  function getValueAtTime(frameNum) {
    frameNum *= this.elem.globalData.frameRate;
    frameNum -= this.offsetTime;
    if (frameNum !== this._cachingAtTime.lastFrame) {
      this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;
      this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);
      this._cachingAtTime.lastFrame = frameNum;
    }
    return this._cachingAtTime.value;
  }

  function getSpeedAtTime(frameNum) {
    var delta = -0.01;
    var v1 = this.getValueAtTime(frameNum);
    var v2 = this.getValueAtTime(frameNum + delta);
    var speed = 0;
    if (v1.length) {
      var i;
      for (i = 0; i < v1.length; i += 1) {
        speed += Math.pow(v2[i] - v1[i], 2);
      }
      speed = Math.sqrt(speed) * 100;
    } else {
      speed = 0;
    }
    return speed;
  }

  function getVelocityAtTime(frameNum) {
    if (this.vel !== undefined) {
      return this.vel;
    }
    var delta = -0.001;
    // frameNum += this.elem.data.st;
    var v1 = this.getValueAtTime(frameNum);
    var v2 = this.getValueAtTime(frameNum + delta);
    var velocity;
    if (v1.length) {
      velocity = createTypedArray('float32', v1.length);
      var i;
      for (i = 0; i < v1.length; i += 1) {
        // removing frameRate
        // if needed, don't add it here
        // velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);
        velocity[i] = (v2[i] - v1[i]) / delta;
      }
    } else {
      velocity = (v2 - v1) / delta;
    }
    return velocity;
  }

  function getStaticValueAtTime() {
    return this.pv;
  }

  function setGroupProperty(propertyGroup) {
    this.propertyGroup = propertyGroup;
  }

  return {
    searchExpressions: searchExpressions,
    getSpeedAtTime: getSpeedAtTime,
    getVelocityAtTime: getVelocityAtTime,
    getValueAtTime: getValueAtTime,
    getStaticValueAtTime: getStaticValueAtTime,
    setGroupProperty: setGroupProperty,
  };
}());

function addPropertyDecorator() {
  function loopOut(type, duration, durationFlag) {
    if (!this.k || !this.keyframes) {
      return this.pv;
    }
    type = type ? type.toLowerCase() : '';
    var currentFrame = this.comp.renderedFrame;
    var keyframes = this.keyframes;
    var lastKeyFrame = keyframes[keyframes.length - 1].t;
    if (currentFrame <= lastKeyFrame) {
      return this.pv;
    }
    var cycleDuration;
    var firstKeyFrame;
    if (!durationFlag) {
      if (!duration || duration > keyframes.length - 1) {
        duration = keyframes.length - 1;
      }
      firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
      cycleDuration = lastKeyFrame - firstKeyFrame;
    } else {
      if (!duration) {
        cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);
      } else {
        cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration);
      }
      firstKeyFrame = lastKeyFrame - cycleDuration;
    }
    var i;
    var len;
    var ret;
    if (type === 'pingpong') {
      var iterations = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
      if (iterations % 2 !== 0) {
          return this.getValueAtTime(((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0);  
      }
    } else if (type === 'offset') {
      var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
      var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
        var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);  
      var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
      if (this.pv.length) {
        ret = new Array(initV.length);
        len = ret.length;
        for (i = 0; i < len; i += 1) {
          ret[i] = (endV[i] - initV[i]) * repeats + current[i];
        }
        return ret;
      }
      return (endV - initV) * repeats + current;
    } else if (type === 'continue') {
      var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
      var nextLastValue = this.getValueAtTime((lastKeyFrame - 0.001) / this.comp.globalData.frameRate, 0);
      if (this.pv.length) {
        ret = new Array(lastValue.length);
        len = ret.length;
        for (i = 0; i < len; i += 1) {
            ret[i] = lastValue[i] + (lastValue[i] - nextLastValue[i]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 0.0005;  
        }
        return ret;
      }
      return lastValue + (lastValue - nextLastValue) * (((currentFrame - lastKeyFrame)) / 0.001);
    }
      return this.getValueAtTime((((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0);  

  }

  function loopIn(type, duration, durationFlag) {
    if (!this.k) {
      return this.pv;
    }
    type = type ? type.toLowerCase() : '';
    var currentFrame = this.comp.renderedFrame;
    var keyframes = this.keyframes;
    var firstKeyFrame = keyframes[0].t;
    if (currentFrame >= firstKeyFrame) {
      return this.pv;
    }
    var cycleDuration;
    var lastKeyFrame;
    if (!durationFlag) {
      if (!duration || duration > keyframes.length - 1) {
        duration = keyframes.length - 1;
      }
      lastKeyFrame = keyframes[duration].t;
      cycleDuration = lastKeyFrame - firstKeyFrame;
    } else {
      if (!duration) {
        cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame);
      } else {
        cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration);
      }
      lastKeyFrame = firstKeyFrame + cycleDuration;
    }
    var i;
    var len;
    var ret;
    if (type === 'pingpong') {
      var iterations = Math.floor((firstKeyFrame - currentFrame) / cycleDuration);
      if (iterations % 2 === 0) {
          return this.getValueAtTime((((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0);  
      }
    } else if (type === 'offset') {
      var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
      var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
      var current = this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration) + firstKeyFrame) / this.comp.globalData.frameRate, 0);
      var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;
      if (this.pv.length) {
        ret = new Array(initV.length);
        len = ret.length;
        for (i = 0; i < len; i += 1) {
          ret[i] = current[i] - (endV[i] - initV[i]) * repeats;
        }
        return ret;
      }
      return current - (endV - initV) * repeats;
    } else if (type === 'continue') {
      var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
      var nextFirstValue = this.getValueAtTime((firstKeyFrame + 0.001) / this.comp.globalData.frameRate, 0);
      if (this.pv.length) {
        ret = new Array(firstValue.length);
        len = ret.length;
        for (i = 0; i < len; i += 1) {
          ret[i] = firstValue[i] + ((firstValue[i] - nextFirstValue[i]) * (firstKeyFrame - currentFrame)) / 0.001;
        }
        return ret;
      }
      return firstValue + ((firstValue - nextFirstValue) * (firstKeyFrame - currentFrame)) / 0.001;
    }
      return this.getValueAtTime(((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame))) / this.comp.globalData.frameRate, 0);  

  }

  function smooth(width, samples) {
    if (!this.k) {
      return this.pv;
    }
    width = (width || 0.4) * 0.5;
    samples = Math.floor(samples || 5);
    if (samples <= 1) {
      return this.pv;
    }
    var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;
    var initFrame = currentTime - width;
    var endFrame = currentTime + width;
    var sampleFrequency = samples > 1 ? (endFrame - initFrame) / (samples - 1) : 1;
    var i = 0;
    var j = 0;
    var value;
    if (this.pv.length) {
      value = createTypedArray('float32', this.pv.length);
    } else {
      value = 0;
    }
    var sampleValue;
    while (i < samples) {
      sampleValue = this.getValueAtTime(initFrame + i * sampleFrequency);
      if (this.pv.length) {
        for (j = 0; j < this.pv.length; j += 1) {
          value[j] += sampleValue[j];
        }
      } else {
        value += sampleValue;
      }
      i += 1;
    }
    if (this.pv.length) {
      for (j = 0; j < this.pv.length; j += 1) {
        value[j] /= samples;
      }
    } else {
      value /= samples;
    }
    return value;
  }

  function getTransformValueAtTime(time) {
    if (!this._transformCachingAtTime) {
      this._transformCachingAtTime = {
        v: new Matrix(),
      };
    }
    /// /
    var matrix = this._transformCachingAtTime.v;
    matrix.cloneFromProps(this.pre.props);
    if (this.appliedTransformations < 1) {
      var anchor = this.a.getValueAtTime(time);
      matrix.translate(
        -anchor[0] * this.a.mult,
        -anchor[1] * this.a.mult,
        anchor[2] * this.a.mult
      );
    }
    if (this.appliedTransformations < 2) {
      var scale = this.s.getValueAtTime(time);
      matrix.scale(
        scale[0] * this.s.mult,
        scale[1] * this.s.mult,
        scale[2] * this.s.mult
      );
    }
    if (this.sk && this.appliedTransformations < 3) {
      var skew = this.sk.getValueAtTime(time);
      var skewAxis = this.sa.getValueAtTime(time);
      matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult);
    }
    if (this.r && this.appliedTransformations < 4) {
      var rotation = this.r.getValueAtTime(time);
      matrix.rotate(-rotation * this.r.mult);
    } else if (!this.r && this.appliedTransformations < 4) {
      var rotationZ = this.rz.getValueAtTime(time);
      var rotationY = this.ry.getValueAtTime(time);
      var rotationX = this.rx.getValueAtTime(time);
      var orientation = this.or.getValueAtTime(time);
      matrix.rotateZ(-rotationZ * this.rz.mult)
        .rotateY(rotationY * this.ry.mult)
        .rotateX(rotationX * this.rx.mult)
        .rotateZ(-orientation[2] * this.or.mult)
        .rotateY(orientation[1] * this.or.mult)
        .rotateX(orientation[0] * this.or.mult);
    }
    if (this.data.p && this.data.p.s) {
      var positionX = this.px.getValueAtTime(time);
      var positionY = this.py.getValueAtTime(time);
      if (this.data.p.z) {
        var positionZ = this.pz.getValueAtTime(time);
        matrix.translate(
          positionX * this.px.mult,
          positionY * this.py.mult,
          -positionZ * this.pz.mult
        );
      } else {
        matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0);
      }
    } else {
      var position = this.p.getValueAtTime(time);
      matrix.translate(
        position[0] * this.p.mult,
        position[1] * this.p.mult,
        -position[2] * this.p.mult
      );
    }
    return matrix;
    /// /
  }

  function getTransformStaticValueAtTime() {
    return this.v.clone(new Matrix());
  }

  var getTransformProperty = TransformPropertyFactory.getTransformProperty;
  TransformPropertyFactory.getTransformProperty = function (elem, data, container) {
    var prop = getTransformProperty(elem, data, container);
    if (prop.dynamicProperties.length) {
      prop.getValueAtTime = getTransformValueAtTime.bind(prop);
    } else {
      prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);
    }
    prop.setGroupProperty = expressionHelpers.setGroupProperty;
    return prop;
  };

  var propertyGetProp = PropertyFactory.getProp;
  PropertyFactory.getProp = function (elem, data, type, mult, container) {
    var prop = propertyGetProp(elem, data, type, mult, container);
    // prop.getVelocityAtTime = getVelocityAtTime;
    // prop.loopOut = loopOut;
    // prop.loopIn = loopIn;
    if (prop.kf) {
      prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);
    } else {
      prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);
    }
    prop.setGroupProperty = expressionHelpers.setGroupProperty;
    prop.loopOut = loopOut;
    prop.loopIn = loopIn;
    prop.smooth = smooth;
    prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);
    prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);
    prop.numKeys = data.a === 1 ? data.k.length : 0;
    prop.propertyIndex = data.ix;
    var value = 0;
    if (type !== 0) {
      value = createTypedArray('float32', data.a === 1 ? data.k[0].s.length : data.k.length);
    }
    prop._cachingAtTime = {
      lastFrame: initialDefaultFrame,
      lastIndex: 0,
      value: value,
    };
    expressionHelpers.searchExpressions(elem, data, prop);
    if (prop.k) {
      container.addDynamicProperty(prop);
    }

    return prop;
  };

  function getShapeValueAtTime(frameNum) {
    // For now this caching object is created only when needed instead of creating it when the shape is initialized.
    if (!this._cachingAtTime) {
      this._cachingAtTime = {
        shapeValue: shapePool.clone(this.pv),
        lastIndex: 0,
        lastTime: initialDefaultFrame,
      };
    }

    frameNum *= this.elem.globalData.frameRate;
    frameNum -= this.offsetTime;
    if (frameNum !== this._cachingAtTime.lastTime) {
      this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;
      this._cachingAtTime.lastTime = frameNum;
      this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);
    }
    return this._cachingAtTime.shapeValue;
  }

  var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();
  var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();

  function ShapeExpressions() {}
  ShapeExpressions.prototype = {
    vertices: function (prop, time) {
      if (this.k) {
        this.getValue();
      }
      var shapePath = this.v;
      if (time !== undefined) {
        shapePath = this.getValueAtTime(time, 0);
      }
      var i;
      var len = shapePath._length;
      var vertices = shapePath[prop];
      var points = shapePath.v;
      var arr = createSizedArray(len);
      for (i = 0; i < len; i += 1) {
        if (prop === 'i' || prop === 'o') {
          arr[i] = [vertices[i][0] - points[i][0], vertices[i][1] - points[i][1]];
        } else {
          arr[i] = [vertices[i][0], vertices[i][1]];
        }
      }
      return arr;
    },
    points: function (time) {
      return this.vertices('v', time);
    },
    inTangents: function (time) {
      return this.vertices('i', time);
    },
    outTangents: function (time) {
      return this.vertices('o', time);
    },
    isClosed: function () {
      return this.v.c;
    },
    pointOnPath: function (perc, time) {
      var shapePath = this.v;
      if (time !== undefined) {
        shapePath = this.getValueAtTime(time, 0);
      }
      if (!this._segmentsLength) {
        this._segmentsLength = bez.getSegmentsLength(shapePath);
      }

      var segmentsLength = this._segmentsLength;
      var lengths = segmentsLength.lengths;
      var lengthPos = segmentsLength.totalLength * perc;
      var i = 0;
      var len = lengths.length;
      var accumulatedLength = 0;
      var pt;
      while (i < len) {
        if (accumulatedLength + lengths[i].addedLength > lengthPos) {
          var initIndex = i;
          var endIndex = (shapePath.c && i === len - 1) ? 0 : i + 1;
          var segmentPerc = (lengthPos - accumulatedLength) / lengths[i].addedLength;
          pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i]);
          break;
        } else {
          accumulatedLength += lengths[i].addedLength;
        }
        i += 1;
      }
      if (!pt) {
        pt = shapePath.c ? [shapePath.v[0][0], shapePath.v[0][1]] : [shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1]];
      }
      return pt;
    },
    vectorOnPath: function (perc, time, vectorType) {
      // perc doesn't use triple equality because it can be a Number object as well as a primitive.
      if (perc == 1) {  
        perc = this.v.c;
      } else if (perc == 0) {  
        perc = 0.999;
      }
      var pt1 = this.pointOnPath(perc, time);
      var pt2 = this.pointOnPath(perc + 0.001, time);
      var xLength = pt2[0] - pt1[0];
      var yLength = pt2[1] - pt1[1];
      var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));
      if (magnitude === 0) {
        return [0, 0];
      }
      var unitVector = vectorType === 'tangent' ? [xLength / magnitude, yLength / magnitude] : [-yLength / magnitude, xLength / magnitude];
      return unitVector;
    },
    tangentOnPath: function (perc, time) {
      return this.vectorOnPath(perc, time, 'tangent');
    },
    normalOnPath: function (perc, time) {
      return this.vectorOnPath(perc, time, 'normal');
    },
    setGroupProperty: expressionHelpers.setGroupProperty,
    getValueAtTime: expressionHelpers.getStaticValueAtTime,
  };
  extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction);
  extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction);
  KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;
  KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;

  var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;
  ShapePropertyFactory.getShapeProp = function (elem, data, type, arr, trims) {
    var prop = propertyGetShapeProp(elem, data, type, arr, trims);
    prop.propertyIndex = data.ix;
    prop.lock = false;
    if (type === 3) {
      expressionHelpers.searchExpressions(elem, data.pt, prop);
    } else if (type === 4) {
      expressionHelpers.searchExpressions(elem, data.ks, prop);
    }
    if (prop.k) {
      elem.addDynamicProperty(prop);
    }
    return prop;
  };
}

function initialize$1() {
  addPropertyDecorator();
}

function addDecorator() {
  function searchExpressions() {
    if (this.data.d.x) {
      this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);
      this.addEffect(this.getExpressionValue.bind(this));
      return true;
    }
    return null;
  }

  TextProperty.prototype.getExpressionValue = function (currentValue, text) {
    var newValue = this.calculateExpression(text);
    if (currentValue.t !== newValue) {
      var newData = {};
      this.copyData(newData, currentValue);
      newData.t = newValue.toString();
      newData.__complete = false;
      return newData;
    }
    return currentValue;
  };

  TextProperty.prototype.searchProperty = function () {
    var isKeyframed = this.searchKeyframes();
    var hasExpressions = this.searchExpressions();
    this.kf = isKeyframed || hasExpressions;
    return this.kf;
  };

  TextProperty.prototype.searchExpressions = searchExpressions;
}

function initialize() {
  addDecorator();
}

function SVGComposableEffect() {

}
SVGComposableEffect.prototype = {
  createMergeNode: (resultId, ins) => {
    var feMerge = createNS('feMerge');
    feMerge.setAttribute('result', resultId);
    var feMergeNode;
    var i;
    for (i = 0; i < ins.length; i += 1) {
      feMergeNode = createNS('feMergeNode');
      feMergeNode.setAttribute('in', ins[i]);
      feMerge.appendChild(feMergeNode);
      feMerge.appendChild(feMergeNode);
    }
    return feMerge;
  },
};

var linearFilterValue = '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0';

function SVGTintFilter(filter, filterManager, elem, id, source) {
  this.filterManager = filterManager;
  var feColorMatrix = createNS('feColorMatrix');
  feColorMatrix.setAttribute('type', 'matrix');
  feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');
  feColorMatrix.setAttribute('values', linearFilterValue + ' 1 0');
  this.linearFilter = feColorMatrix;
  feColorMatrix.setAttribute('result', id + '_tint_1');
  filter.appendChild(feColorMatrix);
  feColorMatrix = createNS('feColorMatrix');
  feColorMatrix.setAttribute('type', 'matrix');
  feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
  feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
  feColorMatrix.setAttribute('result', id + '_tint_2');
  filter.appendChild(feColorMatrix);
  this.matrixFilter = feColorMatrix;
  var feMerge = this.createMergeNode(
    id,
    [
      source,
      id + '_tint_1',
      id + '_tint_2',
    ]
  );
  filter.appendChild(feMerge);
}
extendPrototype([SVGComposableEffect], SVGTintFilter);

SVGTintFilter.prototype.renderFrame = function (forceRender) {
  if (forceRender || this.filterManager._mdf) {
    var colorBlack = this.filterManager.effectElements[0].p.v;
    var colorWhite = this.filterManager.effectElements[1].p.v;
    var opacity = this.filterManager.effectElements[2].p.v / 100;
    this.linearFilter.setAttribute('values', linearFilterValue + ' ' + opacity + ' 0');
    this.matrixFilter.setAttribute('values', (colorWhite[0] - colorBlack[0]) + ' 0 0 0 ' + colorBlack[0] + ' ' + (colorWhite[1] - colorBlack[1]) + ' 0 0 0 ' + colorBlack[1] + ' ' + (colorWhite[2] - colorBlack[2]) + ' 0 0 0 ' + colorBlack[2] + ' 0 0 0 1 0');
  }
};

function SVGFillFilter(filter, filterManager, elem, id) {
  this.filterManager = filterManager;
  var feColorMatrix = createNS('feColorMatrix');
  feColorMatrix.setAttribute('type', 'matrix');
  feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
  feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
  feColorMatrix.setAttribute('result', id);
  filter.appendChild(feColorMatrix);
  this.matrixFilter = feColorMatrix;
}

SVGFillFilter.prototype.renderFrame = function (forceRender) {
  if (forceRender || this.filterManager._mdf) {
    var color = this.filterManager.effectElements[2].p.v;
    var opacity = this.filterManager.effectElements[6].p.v;
    this.matrixFilter.setAttribute('values', '0 0 0 0 ' + color[0] + ' 0 0 0 0 ' + color[1] + ' 0 0 0 0 ' + color[2] + ' 0 0 0 ' + opacity + ' 0');
  }
};

function SVGStrokeEffect(fil, filterManager, elem) {
  this.initialized = false;
  this.filterManager = filterManager;
  this.elem = elem;
  this.paths = [];
}

SVGStrokeEffect.prototype.initialize = function () {
  var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
  var path;
  var groupPath;
  var i;
  var len;
  if (this.filterManager.effectElements[1].p.v === 1) {
    len = this.elem.maskManager.masksProperties.length;
    i = 0;
  } else {
    i = this.filterManager.effectElements[0].p.v - 1;
    len = i + 1;
  }
  groupPath = createNS('g');
  groupPath.setAttribute('fill', 'none');
  groupPath.setAttribute('stroke-linecap', 'round');
  groupPath.setAttribute('stroke-dashoffset', 1);
  for (i; i < len; i += 1) {
    path = createNS('path');
    groupPath.appendChild(path);
    this.paths.push({ p: path, m: i });
  }
  if (this.filterManager.effectElements[10].p.v === 3) {
    var mask = createNS('mask');
    var id = createElementID();
    mask.setAttribute('id', id);
    mask.setAttribute('mask-type', 'alpha');
    mask.appendChild(groupPath);
    this.elem.globalData.defs.appendChild(mask);
    var g = createNS('g');
    g.setAttribute('mask', 'url(' + getLocationHref() + '#' + id + ')');
    while (elemChildren[0]) {
      g.appendChild(elemChildren[0]);
    }
    this.elem.layerElement.appendChild(g);
    this.masker = mask;
    groupPath.setAttribute('stroke', '#fff');
  } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
    if (this.filterManager.effectElements[10].p.v === 2) {
      elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
      while (elemChildren.length) {
        this.elem.layerElement.removeChild(elemChildren[0]);
      }
    }
    this.elem.layerElement.appendChild(groupPath);
    this.elem.layerElement.removeAttribute('mask');
    groupPath.setAttribute('stroke', '#fff');
  }
  this.initialized = true;
  this.pathMasker = groupPath;
};

SVGStrokeEffect.prototype.renderFrame = function (forceRender) {
  if (!this.initialized) {
    this.initialize();
  }
  var i;
  var len = this.paths.length;
  var mask;
  var path;
  for (i = 0; i < len; i += 1) {
    if (this.paths[i].m !== -1) {
      mask = this.elem.maskManager.viewData[this.paths[i].m];
      path = this.paths[i].p;
      if (forceRender || this.filterManager._mdf || mask.prop._mdf) {
        path.setAttribute('d', mask.lastPath);
      }
      if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf) {
        var dasharrayValue;
        if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
          var s = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
          var e = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
          var l = path.getTotalLength();
          dasharrayValue = '0 0 0 ' + l * s + ' ';
          var lineLength = l * (e - s);
          var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
          var units = Math.floor(lineLength / segment);
          var j;
          for (j = 0; j < units; j += 1) {
            dasharrayValue += '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + ' ';
          }
          dasharrayValue += '0 ' + l * 10 + ' 0 0';
        } else {
          dasharrayValue = '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
        }
        path.setAttribute('stroke-dasharray', dasharrayValue);
      }
    }
  }
  if (forceRender || this.filterManager.effectElements[4].p._mdf) {
    this.pathMasker.setAttribute('stroke-width', this.filterManager.effectElements[4].p.v * 2);
  }

  if (forceRender || this.filterManager.effectElements[6].p._mdf) {
    this.pathMasker.setAttribute('opacity', this.filterManager.effectElements[6].p.v);
  }
  if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
    if (forceRender || this.filterManager.effectElements[3].p._mdf) {
      var color = this.filterManager.effectElements[3].p.v;
      this.pathMasker.setAttribute('stroke', 'rgb(' + bmFloor(color[0] * 255) + ',' + bmFloor(color[1] * 255) + ',' + bmFloor(color[2] * 255) + ')');
    }
  }
};

function SVGTritoneFilter(filter, filterManager, elem, id) {
  this.filterManager = filterManager;
  var feColorMatrix = createNS('feColorMatrix');
  feColorMatrix.setAttribute('type', 'matrix');
  feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');
  feColorMatrix.setAttribute('values', '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
  filter.appendChild(feColorMatrix);
  var feComponentTransfer = createNS('feComponentTransfer');
  feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
  feComponentTransfer.setAttribute('result', id);
  this.matrixFilter = feComponentTransfer;
  var feFuncR = createNS('feFuncR');
  feFuncR.setAttribute('type', 'table');
  feComponentTransfer.appendChild(feFuncR);
  this.feFuncR = feFuncR;
  var feFuncG = createNS('feFuncG');
  feFuncG.setAttribute('type', 'table');
  feComponentTransfer.appendChild(feFuncG);
  this.feFuncG = feFuncG;
  var feFuncB = createNS('feFuncB');
  feFuncB.setAttribute('type', 'table');
  feComponentTransfer.appendChild(feFuncB);
  this.feFuncB = feFuncB;
  filter.appendChild(feComponentTransfer);
}

SVGTritoneFilter.prototype.renderFrame = function (forceRender) {
  if (forceRender || this.filterManager._mdf) {
    var color1 = this.filterManager.effectElements[0].p.v;
    var color2 = this.filterManager.effectElements[1].p.v;
    var color3 = this.filterManager.effectElements[2].p.v;
    var tableR = color3[0] + ' ' + color2[0] + ' ' + color1[0];
    var tableG = color3[1] + ' ' + color2[1] + ' ' + color1[1];
    var tableB = color3[2] + ' ' + color2[2] + ' ' + color1[2];
    this.feFuncR.setAttribute('tableValues', tableR);
    this.feFuncG.setAttribute('tableValues', tableG);
    this.feFuncB.setAttribute('tableValues', tableB);
  }
};

function SVGProLevelsFilter(filter, filterManager, elem, id) {
  this.filterManager = filterManager;
  var effectElements = this.filterManager.effectElements;
  var feComponentTransfer = createNS('feComponentTransfer');

  // Red
  if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {
    this.feFuncR = this.createFeFunc('feFuncR', feComponentTransfer);
  }
  // Green
  if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {
    this.feFuncG = this.createFeFunc('feFuncG', feComponentTransfer);
  }
  // Blue
  if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {
    this.feFuncB = this.createFeFunc('feFuncB', feComponentTransfer);
  }
  // Alpha
  if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {
    this.feFuncA = this.createFeFunc('feFuncA', feComponentTransfer);
  }
  // RGB
  if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {
    feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
    filter.appendChild(feComponentTransfer);
  }

  if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {
    feComponentTransfer = createNS('feComponentTransfer');
    feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
    feComponentTransfer.setAttribute('result', id);
    filter.appendChild(feComponentTransfer);
    this.feFuncRComposed = this.createFeFunc('feFuncR', feComponentTransfer);
    this.feFuncGComposed = this.createFeFunc('feFuncG', feComponentTransfer);
    this.feFuncBComposed = this.createFeFunc('feFuncB', feComponentTransfer);
  }
}

SVGProLevelsFilter.prototype.createFeFunc = function (type, feComponentTransfer) {
  var feFunc = createNS(type);
  feFunc.setAttribute('type', 'table');
  feComponentTransfer.appendChild(feFunc);
  return feFunc;
};

SVGProLevelsFilter.prototype.getTableValue = function (inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
  var cnt = 0;
  var segments = 256;
  var perc;
  var min = Math.min(inputBlack, inputWhite);
  var max = Math.max(inputBlack, inputWhite);
  var table = Array.call(null, { length: segments });
  var colorValue;
  var pos = 0;
  var outputDelta = outputWhite - outputBlack;
  var inputDelta = inputWhite - inputBlack;
  while (cnt <= 256) {
    perc = cnt / 256;
    if (perc <= min) {
      colorValue = inputDelta < 0 ? outputWhite : outputBlack;
    } else if (perc >= max) {
      colorValue = inputDelta < 0 ? outputBlack : outputWhite;
    } else {
      colorValue = (outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma));
    }
    table[pos] = colorValue;
    pos += 1;
    cnt += 256 / (segments - 1);
  }
  return table.join(' ');
};

SVGProLevelsFilter.prototype.renderFrame = function (forceRender) {
  if (forceRender || this.filterManager._mdf) {
    var val;
    var effectElements = this.filterManager.effectElements;
    if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {
      val = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);
      this.feFuncRComposed.setAttribute('tableValues', val);
      this.feFuncGComposed.setAttribute('tableValues', val);
      this.feFuncBComposed.setAttribute('tableValues', val);
    }

    if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {
      val = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);
      this.feFuncR.setAttribute('tableValues', val);
    }

    if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {
      val = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);
      this.feFuncG.setAttribute('tableValues', val);
    }

    if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {
      val = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);
      this.feFuncB.setAttribute('tableValues', val);
    }

    if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {
      val = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);
      this.feFuncA.setAttribute('tableValues', val);
    }
  }
};

function SVGDropShadowEffect(filter, filterManager, elem, id, source) {
  var globalFilterSize = filterManager.container.globalData.renderConfig.filterSize;
  var filterSize = filterManager.data.fs || globalFilterSize;
  filter.setAttribute('x', filterSize.x || globalFilterSize.x);
  filter.setAttribute('y', filterSize.y || globalFilterSize.y);
  filter.setAttribute('width', filterSize.width || globalFilterSize.width);
  filter.setAttribute('height', filterSize.height || globalFilterSize.height);
  this.filterManager = filterManager;

  var feGaussianBlur = createNS('feGaussianBlur');
  feGaussianBlur.setAttribute('in', 'SourceAlpha');
  feGaussianBlur.setAttribute('result', id + '_drop_shadow_1');
  feGaussianBlur.setAttribute('stdDeviation', '0');
  this.feGaussianBlur = feGaussianBlur;
  filter.appendChild(feGaussianBlur);

  var feOffset = createNS('feOffset');
  feOffset.setAttribute('dx', '25');
  feOffset.setAttribute('dy', '0');
  feOffset.setAttribute('in', id + '_drop_shadow_1');
  feOffset.setAttribute('result', id + '_drop_shadow_2');
  this.feOffset = feOffset;
  filter.appendChild(feOffset);
  var feFlood = createNS('feFlood');
  feFlood.setAttribute('flood-color', '#00ff00');
  feFlood.setAttribute('flood-opacity', '1');
  feFlood.setAttribute('result', id + '_drop_shadow_3');
  this.feFlood = feFlood;
  filter.appendChild(feFlood);

  var feComposite = createNS('feComposite');
  feComposite.setAttribute('in', id + '_drop_shadow_3');
  feComposite.setAttribute('in2', id + '_drop_shadow_2');
  feComposite.setAttribute('operator', 'in');
  feComposite.setAttribute('result', id + '_drop_shadow_4');
  filter.appendChild(feComposite);

  var feMerge = this.createMergeNode(
    id,
    [
      id + '_drop_shadow_4',
      source,
    ]
  );
  filter.appendChild(feMerge);
  //
}
extendPrototype([SVGComposableEffect], SVGDropShadowEffect);

SVGDropShadowEffect.prototype.renderFrame = function (forceRender) {
  if (forceRender || this.filterManager._mdf) {
    if (forceRender || this.filterManager.effectElements[4].p._mdf) {
      this.feGaussianBlur.setAttribute('stdDeviation', this.filterManager.effectElements[4].p.v / 4);
    }
    if (forceRender || this.filterManager.effectElements[0].p._mdf) {
      var col = this.filterManager.effectElements[0].p.v;
      this.feFlood.setAttribute('flood-color', rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));
    }
    if (forceRender || this.filterManager.effectElements[1].p._mdf) {
      this.feFlood.setAttribute('flood-opacity', this.filterManager.effectElements[1].p.v / 255);
    }
    if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
      var distance = this.filterManager.effectElements[3].p.v;
      var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;
      var x = distance * Math.cos(angle);
      var y = distance * Math.sin(angle);
      this.feOffset.setAttribute('dx', x);
      this.feOffset.setAttribute('dy', y);
    }
  }
};

var _svgMatteSymbols = [];

function SVGMatte3Effect(filterElem, filterManager, elem) {
  this.initialized = false;
  this.filterManager = filterManager;
  this.filterElem = filterElem;
  this.elem = elem;
  elem.matteElement = createNS('g');
  elem.matteElement.appendChild(elem.layerElement);
  elem.matteElement.appendChild(elem.transformedElement);
  elem.baseElement = elem.matteElement;
}

SVGMatte3Effect.prototype.findSymbol = function (mask) {
  var i = 0;
  var len = _svgMatteSymbols.length;
  while (i < len) {
    if (_svgMatteSymbols[i] === mask) {
      return _svgMatteSymbols[i];
    }
    i += 1;
  }
  return null;
};

SVGMatte3Effect.prototype.replaceInParent = function (mask, symbolId) {
  var parentNode = mask.layerElement.parentNode;
  if (!parentNode) {
    return;
  }
  var children = parentNode.children;
  var i = 0;
  var len = children.length;
  while (i < len) {
    if (children[i] === mask.layerElement) {
      break;
    }
    i += 1;
  }
  var nextChild;
  if (i <= len - 2) {
    nextChild = children[i + 1];
  }
  var useElem = createNS('use');
  useElem.setAttribute('href', '#' + symbolId);
  if (nextChild) {
    parentNode.insertBefore(useElem, nextChild);
  } else {
    parentNode.appendChild(useElem);
  }
};

SVGMatte3Effect.prototype.setElementAsMask = function (elem, mask) {
  if (!this.findSymbol(mask)) {
    var symbolId = createElementID();
    var masker = createNS('mask');
    masker.setAttribute('id', mask.layerId);
    masker.setAttribute('mask-type', 'alpha');
    _svgMatteSymbols.push(mask);
    var defs = elem.globalData.defs;
    defs.appendChild(masker);
    var symbol = createNS('symbol');
    symbol.setAttribute('id', symbolId);
    this.replaceInParent(mask, symbolId);
    symbol.appendChild(mask.layerElement);
    defs.appendChild(symbol);
    var useElem = createNS('use');
    useElem.setAttribute('href', '#' + symbolId);
    masker.appendChild(useElem);
    mask.data.hd = false;
    mask.show();
  }
  elem.setMatte(mask.layerId);
};

SVGMatte3Effect.prototype.initialize = function () {
  var ind = this.filterManager.effectElements[0].p.v;
  var elements = this.elem.comp.elements;
  var i = 0;
  var len = elements.length;
  while (i < len) {
    if (elements[i] && elements[i].data.ind === ind) {
      this.setElementAsMask(this.elem, elements[i]);
    }
    i += 1;
  }
  this.initialized = true;
};

SVGMatte3Effect.prototype.renderFrame = function () {
  if (!this.initialized) {
    this.initialize();
  }
};

function SVGGaussianBlurEffect(filter, filterManager, elem, id) {
  // Outset the filter region by 100% on all sides to accommodate blur expansion.
  filter.setAttribute('x', '-100%');
  filter.setAttribute('y', '-100%');
  filter.setAttribute('width', '300%');
  filter.setAttribute('height', '300%');

  this.filterManager = filterManager;
  var feGaussianBlur = createNS('feGaussianBlur');
  feGaussianBlur.setAttribute('result', id);
  filter.appendChild(feGaussianBlur);
  this.feGaussianBlur = feGaussianBlur;
}

SVGGaussianBlurEffect.prototype.renderFrame = function (forceRender) {
  if (forceRender || this.filterManager._mdf) {
    // Empirical value, matching AE's blur appearance.
    var kBlurrinessToSigma = 0.3;
    var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma;

    // Dimensions mapping:
    //
    //   1 -> horizontal & vertical
    //   2 -> horizontal only
    //   3 -> vertical only
    //
    var dimensions = this.filterManager.effectElements[1].p.v;
    var sigmaX = (dimensions == 3) ? 0 : sigma;  
    var sigmaY = (dimensions == 2) ? 0 : sigma;  

    this.feGaussianBlur.setAttribute('stdDeviation', sigmaX + ' ' + sigmaY);

    // Repeat edges mapping:
    //
    //   0 -> off -> duplicate
    //   1 -> on  -> wrap
    var edgeMode = (this.filterManager.effectElements[2].p.v == 1) ? 'wrap' : 'duplicate';  
    this.feGaussianBlur.setAttribute('edgeMode', edgeMode);
  }
};

function TransformEffect() {
}

TransformEffect.prototype.init = function (effectsManager) {
  this.effectsManager = effectsManager;
  this.type = effectTypes.TRANSFORM_EFFECT;
  this.matrix = new Matrix();
  this.opacity = -1;
  this._mdf = false;
  this._opMdf = false;
};

TransformEffect.prototype.renderFrame = function (forceFrame) {
  this._opMdf = false;
  this._mdf = false;
  if (forceFrame || this.effectsManager._mdf) {
    var effectElements = this.effectsManager.effectElements;
    var anchor = effectElements[0].p.v;
    var position = effectElements[1].p.v;
    var isUniformScale = effectElements[2].p.v === 1;
    var scaleHeight = effectElements[3].p.v;
    var scaleWidth = isUniformScale ? scaleHeight : effectElements[4].p.v;
    var skew = effectElements[5].p.v;
    var skewAxis = effectElements[6].p.v;
    var rotation = effectElements[7].p.v;
    this.matrix.reset();
    this.matrix.translate(-anchor[0], -anchor[1], anchor[2]);
    this.matrix.scale(scaleWidth * 0.01, scaleHeight * 0.01, 1);
    this.matrix.rotate(-rotation * degToRads);
    this.matrix.skewFromAxis(-skew * degToRads, (skewAxis + 90) * degToRads);
    this.matrix.translate(position[0], position[1], 0);
    this._mdf = true;
    if (this.opacity !== effectElements[8].p.v) {
      this.opacity = effectElements[8].p.v;
      this._opMdf = true;
    }
  }
};

function SVGTransformEffect(_, filterManager) {
  this.init(filterManager);
}

extendPrototype([TransformEffect], SVGTransformEffect);

function CVTransformEffect(effectsManager) {
  this.init(effectsManager);
}
extendPrototype([TransformEffect], CVTransformEffect);

// Registering renderers
registerRenderer('canvas', CanvasRenderer);
registerRenderer('html', HybridRenderer);
registerRenderer('svg', SVGRenderer);

// Registering shape modifiers
ShapeModifiers.registerModifier('tm', TrimModifier);
ShapeModifiers.registerModifier('pb', PuckerAndBloatModifier);
ShapeModifiers.registerModifier('rp', RepeaterModifier);
ShapeModifiers.registerModifier('rd', RoundCornersModifier);
ShapeModifiers.registerModifier('zz', ZigZagModifier);
ShapeModifiers.registerModifier('op', OffsetPathModifier);

// Registering expression plugin
setExpressionsPlugin(Expressions);
setExpressionInterfaces(getInterface);
initialize$1();
initialize();

// Registering svg effects
registerEffect$1(20, SVGTintFilter, true);
registerEffect$1(21, SVGFillFilter, true);
registerEffect$1(22, SVGStrokeEffect, false);
registerEffect$1(23, SVGTritoneFilter, true);
registerEffect$1(24, SVGProLevelsFilter, true);
registerEffect$1(25, SVGDropShadowEffect, true);
registerEffect$1(28, SVGMatte3Effect, false);
registerEffect$1(29, SVGGaussianBlurEffect, true);
registerEffect$1(35, SVGTransformEffect, false);
registerEffect(35, CVTransformEffect);

export { lottie as default };
