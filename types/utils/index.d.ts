import type { AnimationDirection, Constructor, IntersectData, Vector2, Vector3, Vector4 } from '../types';
import type Matrix from '../utils/Matrix';
import type ShapePath from '../utils/shapes/ShapePath';
import PolynomialBezier from '../utils/PolynomialBezier';
export declare const degToRads: number, hueToRGB: (p: number, q: number, tFromProps: number) => number, intersectData: (bez: PolynomialBezier, t1: number, t2: number) => IntersectData, floatEqual: (a: number, b: number) => boolean, floatZero: (f: number) => boolean, isServer: () => boolean, parsePayloadLines: (payload: string) => Record<string, string>, pointEqual: (p1: Vector2, p2: Vector2) => boolean, polarOffset: (p: Vector2, angle: number, length: number) => Vector2;
export declare const addBrightnessToRGB: (color: Vector3, offset: number) => Vector3, addHueToRGB: (color: Vector3, offset: number) => Vector3, addSaturationToRGB: (color: Vector3, offset: number) => Vector3, buildShapeString: (pathNodes: ShapePath, length: number, closed: boolean, mat: Matrix) => string, createElementID: () => string, clamp: (n: number, minFromProps?: number, maxFromProps?: number) => number, createNS: <T extends SVGElement>(type: string) => T, createTag: <T extends HTMLElement>(type: string) => T, createQuaternion: (values: Vector3) => Vector4, extendPrototype: (sources: Constructor[], destination: Constructor) => void, getBlendMode: (mode?: number) => string, getDescriptor: (object: unknown, prop: PropertyKey) => PropertyDescriptor | undefined, getProjectingAngle: (path: ShapePath, cur: number) => number, hslToRgb: (val: number[]) => Vector4, inBrowser: () => boolean, intersectsImpl: (d1: IntersectData, d2: IntersectData, depth: number, tolerance: number, intersections: unknown[], maxRecursion: number) => void, isArray: <T>(input: unknown) => input is T[], isArrayOfNum: (input: unknown) => input is number[], isDeclaration: (str: string) => str is "var" | "let" | "const", isSafari: () => boolean, joinLines: (outputBezier: ShapePath, seg1: PolynomialBezier, seg2: PolynomialBezier, lineJoin: number, miterLimit: number) => Vector2, lerpPoint: (p0: Vector2, p1: Vector2, amount: number) => Vector2, logPrototype: (sources: Constructor[], destination?: Constructor) => void, offsetSegmentSplit: (segment: PolynomialBezier, amount: number) => PolynomialBezier[], polynomialCoefficients: (p0: number, p1: number, p2: number, p3: number) => number[], pruneIntersections: (segments: PolynomialBezier[][]) => PolynomialBezier[][], quadRoots: (a: number, b: number, c: number) => number[], quaternionToEuler: (out: Vector3, quat: Vector4) => void, rgbToHex: (rVal: number, gVal: number, bVal: number) => string, rgbToHsl: (val: Vector4) => number[], setPoint: (outputBezier: ShapePath, point: Vector2, angle: number, direction: AnimationDirection, amplitude: number, outAmplitude: number, inAmplitude: number) => void, singlePoint: (p: Vector2) => PolynomialBezier, slerp: (a: Vector4, b: Vector4, t: number) => Vector4, styleDiv: (element: HTMLElement | SVGSVGElement) => void;
