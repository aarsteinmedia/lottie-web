import type { CompElementInterface, ElementInterfaceIntersect, GlobalData, Vector2, Vector3 } from '../../types';
import type CompExpressionInterface from '../../utils/expressions/CompInterface';
import type LayerExpressionInterface from '../../utils/expressions/LayerInterface';
import type MaskManager from '../../utils/expressions/MaskInterface';
import type TextExpressionInterface from '../../utils/expressions/TextInterface';
import type TextExpressionSelectorPropFactory from '../../utils/expressions/TextSelectorPropertyDecorator';
import type { BaseProperty, ValueProperty } from '../../utils/Properties';
import type ShapePath from '../../utils/shapes/ShapePath';
import type TextSelectorProperty from '../../utils/text/TextSelectorProperty';
export default class ExpressionManager {
    _lottieGlobal: {};
    _needsRandom?: boolean;
    $bm_div: (a: number | number[], b: number | number[]) => number | number[] | Uint8ClampedArray<ArrayBuffer> | Int16Array<ArrayBuffer> | Float32Array<ArrayBuffer>;
    $bm_mod: (aFromProps: string | number, bFromProps: string | number) => number;
    $bm_mul: (a: number | number[], b: number | number[]) => number | number[];
    $bm_sub: (aFromProps: string | number | number[], bFromProps: string | number | number[]) => number | number[];
    $bm_sum: (aFromProps: number | number[], bFromProps: number | number[]) => number | number[];
    $bm_transform?: any;
    active?: boolean;
    anchorPoint?: Vector2;
    comp?: CompElementInterface;
    content?: typeof LayerExpressionInterface;
    data: any;
    document: null;
    effect?: any;
    elem?: ElementInterfaceIntersect;
    elemType?: number;
    fetch: null;
    frameExpressionId?: number;
    frames: null;
    getValueAtTime: any;
    getVelocityAtTime: any;
    globalData?: GlobalData;
    hasParent?: boolean;
    height: number;
    helperLengthArray: number[];
    index?: number;
    inPoint: number;
    mask?: MaskManager;
    name: string;
    needsVelocity?: boolean;
    numKeys: number;
    outPoint: number;
    parent?: LayerExpressionInterface;
    position?: Vector2;
    propType?: string;
    pv?: number | number[];
    randSeed: number;
    rotation?: number;
    scale?: number;
    scoped_bm_rt?: ValueProperty;
    selectorValue?: number;
    text?: TextExpressionInterface;
    textIndex?: number;
    textTotal?: number;
    thisComp?: CompExpressionInterface;
    thisLayer?: LayerExpressionInterface;
    time: number;
    transform?: typeof LayerExpressionInterface;
    val?: string | number | number[];
    value?: string | number | number[];
    velocity?: number;
    width: number;
    window: null;
    XMLHttpRequest: null;
    $bm_isInstanceOfArray(arr: unknown): arr is number[];
    $bm_neg(a: number | boolean | BaseProperty): string | number | number[] | import("../Matrix").default | import("../../types").DocumentData | undefined;
    add(_a: number | number[], _b: number | number[]): void;
    applyEase(fn: (val: number) => number, tFromProps: number, tMin: number, tMax: number, val1FromProps?: number | number[], val2FromProps?: number | number[]): number | number[] | Uint8ClampedArray<ArrayBuffer> | Int16Array<ArrayBuffer> | Float32Array<ArrayBuffer>;
    clamp(num: number, minFromProps: number, maxFromProps: number): number;
    createPath(points: Vector2[], inTangents?: Vector2[], outTangents?: Vector2[], closed?: boolean): ShapePath;
    degrees_to_radians(_val: number): void;
    degreesToRadians(val: number): number;
    div(a: number | number[], b: number | number[]): number | number[] | Uint8ClampedArray<ArrayBuffer> | Int16Array<ArrayBuffer> | Float32Array<ArrayBuffer>;
    ease(t: number, tMin: number, tMax: number, val1?: number | number[], val2?: number | number[]): number | number[] | Uint8ClampedArray<ArrayBuffer> | Int16Array<ArrayBuffer> | Float32Array<ArrayBuffer>;
    easeIn(t: number, tMin: number, tMax: number, val1?: number | number[], val2?: number | number[]): number | number[] | Uint8ClampedArray<ArrayBuffer> | Int16Array<ArrayBuffer> | Float32Array<ArrayBuffer>;
    easeInBez(_val: number): number;
    easeInOutBez(_val: number): number;
    easeOut(t: number, tMin: number, tMax: number, val1?: number | number[], val2?: number | number[]): number | number[] | Uint8ClampedArray<ArrayBuffer> | Int16Array<ArrayBuffer> | Float32Array<ArrayBuffer>;
    easeOutBez(_val: number): number;
    executeExpression<T extends number | number[] | string = number>(_value?: T): T;
    expression_function(): void;
    framesToTime(fr: number, fpsFromProps?: number): number;
    fromComp(_arr: number[], _time?: number): void;
    fromCompToSurface(_arr: number[], _time?: number): void;
    fromWorld(_arr: number[], _time?: number): void;
    initiateExpression(elem: ElementInterfaceIntersect, data: TextSelectorProperty, property: TextExpressionSelectorPropFactory): (_value?: unknown) => unknown;
    isNumerable(tOfV: string, v: unknown): v is number;
    key(indFromProps: number): {
        [key: number]: any;
        time: number;
        value: any[];
    };
    length(arr1: number | number[], arr2FromProps?: number | number[]): number;
    linear(t: number, tMinFromProps: number, tMaxFromProps: number, value1FromProps: number | number[], value2FromProps: number | number[]): number | number[] | Uint8ClampedArray<ArrayBuffer> | Int16Array<ArrayBuffer> | Float32Array<ArrayBuffer>;
    lookAt(elem1: number[], elem2: number[]): Vector3;
    loop_in(_type?: string, _duration?: number, _flag?: boolean): void;
    loop_out(_type?: string, _duration?: number, _flag?: boolean): void;
    loopIn(_type?: string, _duration?: number, _flag?: boolean): void;
    loopInDuration(type: string, duration: number): void;
    loopOut(_type?: string, _duration?: number, _flag?: boolean): void;
    loopOutDuration(type: string, duration: number): void;
    mod(aFromProps: string | number, bFromProps: string | number): number;
    mul(a: number | number[], b: number | number[]): number | number[];
    nearestKey(timeFromProps: number): {
        index: number;
        time: number;
    };
    normalize(vec: number[]): number | number[] | Uint8ClampedArray<ArrayBuffer> | Int16Array<ArrayBuffer> | Float32Array<ArrayBuffer>;
    posterizeTime(framesPerSecond: number): void;
    radians_to_degrees(_val: number): void;
    radiansToDegrees(val: number): number;
    random(minFromProps?: number | number[], maxFromProps?: number | number[]): number | number[] | Uint8ClampedArray<ArrayBuffer> | Int16Array<ArrayBuffer> | Float32Array<ArrayBuffer>;
    resetFrame(): void;
    seedRandom(_seed: number): void;
    smooth(): void;
    sourceRectAtTime(): import("../../types").SourceRect | null | undefined;
    sub(aFromProps: string | number | number[], bFromProps: string | number | number[]): number | number[];
    substr(init: number, end?: number): string;
    substring(init: number, end?: number): string;
    sum(aFromProps: number | number[], bFromProps: number | number[]): number | number[];
    timeToFrames(tFromProps?: number, fpsFromProps?: number): number;
    toComp(_arr: number[], _time?: number): void;
    toWorld(_arr: number[], _time?: number): number[];
    valueAtTime(_num: number): string | number | number[];
    velocityAtTime(_num: number): number;
    wiggle(freqFromProps: number, amp: number): number | number[] | Uint8ClampedArray<ArrayBuffer> | Int16Array<ArrayBuffer> | Float32Array<ArrayBuffer>;
    private noOp;
}
